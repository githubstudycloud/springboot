您指出的问题非常关键！`cell.attr("style")` 获取的是 `style` 属性的 *字面值*。如果这个值本身包含了 HTML 转义字符，比如 `&quot;`，那么 Jsoup 不会自动解码它内部的内容。我们需要手动处理这种情况。

**问题分析:**

* **HTML 结构:** 您的 HTML 中，样式被这样编码了：`<td style=" &quot;background-color: rgb(...)&quot; ">`。
* **Jsoup 获取:** `cell.attr("style")` 会得到字符串 `" &quot;background-color: rgb(...)&quot; "` (包含前后的空格和转义的引号)。
* **现有逻辑失效:** 原来的代码期望直接得到 CSS 声明 `background-color: rgb(...);`，所以基于分号 `;` 和冒号 `:` 的分割解析会失败。

**解决方案:**

1.  **获取原始属性值:** 继续使用 `cell.attr("style")`。
2.  **清理和解码:**
    * 去除获取到的字符串前后的空格。
    * 检查字符串是否以 `&quot;` 开头并以 `&quot;` 结尾。如果是，则移除它们。
    * **（重要）** 对移除包裹后的字符串进行 **HTML 实体解码**，将内部可能存在的其他转义（如 `&amp;` 变回 `&`）还原。可以使用 Jsoup 内置的 `Parser.unescapeEntities`。
3.  **解析清理后的 CSS:** 将清理和解码后的、符合标准 CSS 格式的字符串传递给后续的解析逻辑。
4.  **处理嵌套 `<span>`:** 您提到 `<th>` 或 `<td>` 内部的 `<span>` 也可能包含样式。一个合理的策略是：**优先使用 `<td>`/`<th>` 内部第一个 `<span>` 标签的 `style` 属性（如果存在且有内容），如果 `<span>` 没有样式，再使用 `<td>`/`<th>` 自身的 `style` 属性。** 这样可以应用更具体的样式。

**修改后的代码:**

我们将修改 `createAndCacheStyleFromHtml` 方法来加入清理和解码逻辑，并优先考虑 `<span>` 的样式。

```java
package com.example.htmltoxlsx.service; // Adjust package name as needed

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI (XSSF for .xlsx output) imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.DefaultIndexedColorMap;
import org.apache.poi.xssf.usermodel.extensions.XSSFCellBorder.BorderSide;
import org.apache.poi.ss.util.WorkbookUtil; // For safe sheet names

// Jsoup (HTML Parsing) imports
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.parser.Parser; // Import Jsoup Parser for unescaping

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.awt.Color;

// Commons IO / Lang imports
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.lang3.StringUtils;


@Service
@Slf4j
public class ExcelConversionService {

    // --- Caches for Performance ---
    private final Map<String, XSSFCellStyle> htmlStyleCache = new HashMap<>();
    private final Map<String, XSSFFont> htmlFontCache = new HashMap<>();

    // --- Limits ---
    private static final int MAX_SUPPORTED_ROWS = 100000;
    private static final int MAX_SUPPORTED_COLS = 200;

    // --- Main Conversion Method ---
    public byte[] convertOuterHtmlTableToXlsx(MultipartFile file) throws IOException {
        // ... (Input checks, try-with-resources, reading file to String - Same as before) ...
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }
        String originalFilename = file.getOriginalFilename();
        log.info("Attempting conversion of HTML table from file ({}) to XLSX format.", originalFilename);
        htmlStyleCache.clear(); htmlFontCache.clear(); // Clear caches

        try (InputStream inputStream = file.getInputStream();
             XSSFWorkbook workbook = new XSSFWorkbook();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            String htmlContent = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
            if (StringUtils.isBlank(htmlContent)) {
                 throw new IllegalArgumentException("Input file contains no processable content.");
            }

            Document doc = Jsoup.parseBodyFragment(htmlContent);
            log.debug("Parsed input stream as HTML body fragment.");

            Element table = doc.body().selectFirst("table");
            if (table == null) {
                throw new IllegalArgumentException("The provided content does not contain a valid HTML table structure.");
            }
            log.debug("Found the first HTML table element to process.");

            String sheetName = "Sheet1";
            XSSFSheet sheet = workbook.createSheet(sheetName);
            log.debug("Processing HTML table into sheet '{}'", sheetName);

            processHtmlTableToSheet(table, sheet, workbook); // Call main processing logic

            workbook.write(baos);
            log.info("Successfully converted HTML table from {} to XLSX format (Sheet: '{}').", originalFilename, sheetName);
            return baos.toByteArray();

        } catch (IOException ioe) { /* ... error handling ... */ throw ioe; }
        catch (OutOfMemoryError oom) { /* ... error handling ... */ throw new IOException("OOM Error", oom); }
        catch (Exception e) { /* ... error handling ... */ throw new IOException("Conversion Error", e); }
        finally { htmlStyleCache.clear(); htmlFontCache.clear(); } // Ensure cleanup
    }

    // --- Processes a single HTML table element into an XSSFSheet ---
    private void processHtmlTableToSheet(Element table, XSSFSheet sheet, XSSFWorkbook workbook) {
        // ... (Row iteration, occupancy grid, column char map - Same as before) ...
         Elements rows = table.select("tr");
         int rowIndex = 0;
         boolean[][] cellOccupied = new boolean[Math.min(rows.size(), MAX_SUPPORTED_ROWS) + 5][MAX_SUPPORTED_COLS + 5];
         Map<Integer, Integer> columnMaxChars = new HashMap<>();

         for (Element row : rows) {
              if (rowIndex >= MAX_SUPPORTED_ROWS) break;
             XSSFRow xssfRow = sheet.createRow(rowIndex);
             Elements cells = row.select("th, td");
             int currentCellIndex = 0;

             for (Element cell : cells) {
                  while (currentCellIndex < MAX_SUPPORTED_COLS && cellOccupied[rowIndex][currentCellIndex]) currentCellIndex++;
                  if (currentCellIndex >= MAX_SUPPORTED_COLS) break;

                 XSSFCell xssfCell = xssfRow.createCell(currentCellIndex);
                 String cellText = cell.text();
                 setCellValue(xssfCell, cellText);
                 updateMaxChars(columnMaxChars, currentCellIndex, cellText);

                 // *** Call the MODIFIED style creation method ***
                 XSSFCellStyle xssfStyle = createAndCacheStyleFromHtml(cell, workbook);
                 if (xssfStyle != null) xssfCell.setCellStyle(xssfStyle);

                 // ... (Colspan/Rowspan handling - Same as before) ...
                 int colspan = NumberUtils.toInt(cell.attr("colspan"), 1);
                 int rowspan = NumberUtils.toInt(cell.attr("rowspan"), 1);
                 rowspan = Math.min(rowspan, MAX_SUPPORTED_ROWS - rowIndex);
                 colspan = Math.min(colspan, MAX_SUPPORTED_COLS - currentCellIndex);
                 handleMergedRegions(sheet, cellOccupied, rowIndex, currentCellIndex, rowspan, colspan);

                 currentCellIndex += colspan;
             }
             rowIndex++;
         }
         applyColumnWidths(sheet, columnMaxChars); // Apply widths at the end
    }


    // --- Helper: Create/Cache XSSFCellStyle from HTML inline style attribute ---
    // *** MODIFIED to handle encoded styles and prioritize spans ***
    private XSSFCellStyle createAndCacheStyleFromHtml(Element cell, XSSFWorkbook workbook) {
        String rawStyleAttr = null;
        boolean styleFromSpan = false;

        // 1. Prioritize style from the first span inside the cell, if present
        Element firstSpan = cell.selectFirst("span");
        if (firstSpan != null) {
            String spanStyle = firstSpan.attr("style");
            if (StringUtils.isNotBlank(spanStyle)) {
                rawStyleAttr = spanStyle;
                styleFromSpan = true;
                log.trace("Using style from inner span."); // Simple trace log
            }
        }

        // 2. If no span style found, use the cell's style attribute
        if (rawStyleAttr == null) {
            rawStyleAttr = cell.attr("style");
        }

        // 3. If still no style attribute, return null
        if (StringUtils.isBlank(rawStyleAttr)) {
            return null;
        }

        // 4. *** Clean and Decode the Raw Style String ***
        String cleanedStyleAttr = cleanAndDecodeStyleAttribute(rawStyleAttr);
        if (StringUtils.isBlank(cleanedStyleAttr)) {
             log.trace("Style attribute was blank after cleaning/decoding: Raw='{}'", rawStyleAttr);
            return null; // Style was effectively blank
        }

        // 5. --- Caching based on the *cleaned* style string ---
        if (htmlStyleCache.containsKey(cleanedStyleAttr)) {
            return htmlStyleCache.get(cleanedStyleAttr);
        }

        // 6. --- Style Creation & Parsing (using cleanedStyleAttr) ---
        XSSFCellStyle style = workbook.createCellStyle();
        XSSFFont baseFont = workbook.getFontAt((short) 0);
        XSSFFont currentFont = baseFont;
        boolean fontNeedsCloning = true;
        boolean fontIsModified = false;
        boolean styleIsModified = false;

        // Set Excel defaults that might differ from HTML implicit defaults
        style.setWrapText(false); // Excel default: no wrap

        // --- Parse CSS Declarations from the cleaned string ---
        String[] declarations = cleanedStyleAttr.split(";"); // Split cleaned string
        for (String declaration : declarations) {
             // ... (Split property/value - Same as before) ...
             if (StringUtils.isBlank(declaration)) continue;
             String[] parts = declaration.split(":", 2);
             if (parts.length != 2) continue;
             String property = parts[0].trim().toLowerCase();
             String value = parts[1].trim().toLowerCase();

            try {
                // Clone font ONCE if needed
                if (fontNeedsCloning && isFontProperty(property)) {
                    XSSFFont clonedFont = workbook.createFont();
                    clonedFont.cloneStyleFrom(baseFont);
                    currentFont = clonedFont;
                    fontNeedsCloning = false;
                    fontIsModified = true;
                }

                // Apply styles
                boolean applied = applyCssProperty(property, value, style, currentFont);
                if (applied) styleIsModified = true;

            } catch (Exception e) {
                 log.warn("Could not parse/apply style property from cleaned string: '{}':'{}'. Error: {}", property, value, e.getMessage());
            }
        }

        // --- Final Font Handling ---
        if (fontIsModified) {
            String fontKey = generateFontKey(currentFont);
            XSSFFont finalFont = htmlFontCache.computeIfAbsent(fontKey, k -> currentFont);
            style.setFont(finalFont);
            styleIsModified = true;
        }

        // --- Cache and Return ---
        if (styleIsModified) {
            // Cache using the cleaned key that led to this style
            htmlStyleCache.put(cleanedStyleAttr, style);
            return style;
        } else {
            return null; // No non-default styles were applied
        }
    }

    // --- *** NEW Helper function to clean and decode style attribute *** ---
    private String cleanAndDecodeStyleAttribute(String rawStyle) {
        if (rawStyle == null) return null;
        String cleaned = rawStyle.trim();

        // 1. Remove surrounding &quot; if present
        if (cleaned.startsWith("&quot;") && cleaned.endsWith("&quot;")) {
            // Check length before substring to avoid errors
            if (cleaned.length() >= 12) { // Length of &quot; is 6
                 cleaned = cleaned.substring(6, cleaned.length() - 6);
            } else {
                 cleaned = ""; // Invalid encoding, treat as empty
            }
        }
        // 2. Remove surrounding standard quotes " if present (less likely)
        else if (cleaned.startsWith("\"") && cleaned.endsWith("\"")) {
             if (cleaned.length() >= 2) {
                 cleaned = cleaned.substring(1, cleaned.length() - 1);
             } else {
                 cleaned = "";
             }
        }

        // 3. Unescape HTML entities within the style definition (e.g., &amp; -> &)
        // Using Jsoup's built-in parser is safe and efficient
        if (cleaned.contains("&")) { // Optimization: only unescape if entities likely exist
            // 'false' means it's not in an attribute context for unescaping purposes here
            cleaned = Parser.unescapeEntities(cleaned, false);
        }

        return cleaned.trim(); // Trim again after potential unescaping
    }


    // --- Helper to check if a CSS property affects the font ---
    // (Same as before)
    private boolean isFontProperty(String property) {
         return property.startsWith("font-") || property.equals("color") || property.equals("text-decoration");
    }

    // --- Helper to apply a single CSS property ---
    // (Same as before - calls specific apply/parse helpers)
    private boolean applyCssProperty(String property, String value, XSSFCellStyle style, XSSFFont font) {
        boolean applied = false;
        switch (property) {
            case "text-align": applied = applyTextAlign(style, value); break;
            case "vertical-align": applied = applyVerticalAlign(style, value); break;
            case "background-color": applied = applyBackgroundColor(style, value); break;
            case "color": applied = applyFontColor(font, value); break;
            case "font-weight": applied = applyFontWeight(font, value); break;
            case "font-style": applied = applyFontStyle(font, value); break;
            case "font-size": applied = parseFontSize(value, font); break;
            case "font-family": applied = parseFontFamily(value, font); break;
            case "text-decoration": applied = parseTextDecoration(value, font); break;
            case "white-space": if ("nowrap".equals(value)) style.setWrapText(false); else style.setWrapText(true); applied = true; break;
            case "border": applied = parseGeneralBorder(value, style); break;
            case "border-top": applied = parseSpecificBorder(value, style, BorderSide.TOP); break;
            case "border-bottom": applied = parseSpecificBorder(value, style, BorderSide.BOTTOM); break;
            case "border-left": applied = parseSpecificBorder(value, style, BorderSide.LEFT); break;
            case "border-right": applied = parseSpecificBorder(value, style, BorderSide.RIGHT); break;
             default: break;
        }
        return applied;
    }


    // --- All other helper methods (updateMaxChars, applyColumnWidths, setCellValue, ---
    // --- handleMergedRegions, applyTextAlign, applyVerticalAlign, applyBackgroundColor, ---
    // --- applyFontColor, applyFontWeight, applyFontStyle, parseFontSize, parseFontFamily, ---
    // --- parseTextDecoration, BorderSettings class, parseGeneralBorder, parseSpecificBorder, ---
    // --- parseBorderSettings, mapCssBorderStyle, parseColor, mapColorNameToRgb, constrain, ---
    // --- generateFontKey) remain IDENTICAL to the previous HTML->XLSX version. ---
    // --- Make sure you have copied them correctly from the previous response. ---

    // ... (Paste ALL the remaining helper methods from the previous correct response here) ...

    // --- Helper: Update max characters seen for a column ---
    private void updateMaxChars(Map<Integer, Integer> maxCharsMap, int colIndex, String text) {
        int length = (text != null) ? text.length() : 0;
        maxCharsMap.put(colIndex, Math.max(length, maxCharsMap.getOrDefault(colIndex, 0)));
    }

    // --- Helper: Apply estimated column widths ---
    private void applyColumnWidths(XSSFSheet sheet, Map<Integer, Integer> maxCharsMap) {
         final int charWidthFactor = 256; final int padding = 2;
         final double defaultCharWidthApproximation = 1.0; final int minWidthChars = 8;
         final int maxWidthChars = 100; final int excelMaxWidthUnits = 255 * charWidthFactor;
        log.debug("Applying estimated column widths for sheet '{}'", sheet.getSheetName());
        for (Map.Entry<Integer, Integer> entry : maxCharsMap.entrySet()) {
             int colIndex = entry.getKey(); int maxChars = entry.getValue();
             int clampedMaxChars = Math.min(maxChars, maxWidthChars);
             int width = (int) ((clampedMaxChars + padding) * defaultCharWidthApproximation * charWidthFactor);
             width = Math.max(width, minWidthChars * charWidthFactor);
             width = Math.min(width, excelMaxWidthUnits);
             try { sheet.setColumnWidth(colIndex, width); }
             catch (Exception e) { log.warn("Failed to set width for column {} on sheet '{}'. Error: {}", colIndex, sheet.getSheetName(), e.getMessage()); }
        }
    }

    // --- Helper: Set cell value with basic type detection ---
    private void setCellValue(XSSFCell cell, String text) {
        if (text == null) { cell.setBlank(); return; }
        String trimmedText = text.trim();
        if ("true".equalsIgnoreCase(trimmedText)) { cell.setCellValue(true); return; }
        if ("false".equalsIgnoreCase(trimmedText)) { cell.setCellValue(false); return; }
        if (NumberUtils.isCreatable(trimmedText)) {
            try { cell.setCellValue(Double.parseDouble(trimmedText)); return;
            } catch (NumberFormatException e) { /* Fallback */ }
        }
        cell.setCellValue(trimmedText);
    }

    // --- Helper: Handle Merged Regions ---
    private void handleMergedRegions(XSSFSheet sheet, boolean[][] occupied, int rIdx, int cIdx, int rowspan, int colspan) {
        if (rowspan > 1 || colspan > 1) {
            if (rIdx >= MAX_SUPPORTED_ROWS || cIdx >= MAX_SUPPORTED_COLS) return;
            int lastRow = Math.min(rIdx + rowspan - 1, MAX_SUPPORTED_ROWS - 1);
            int lastCol = Math.min(cIdx + colspan - 1, MAX_SUPPORTED_COLS - 1);
            if (lastRow < rIdx || lastCol < cIdx) return;
            try {
                CellRangeAddress mergedRegion = new CellRangeAddress(rIdx, lastRow, cIdx, lastCol);
                sheet.addMergedRegion(mergedRegion);
                log.trace("Added merged region: {}", mergedRegion.formatAsString());
                for (int r = rIdx; r <= lastRow; r++) {
                     if (r >= occupied.length) continue;
                    for (int c = cIdx; c <= lastCol; c++) {
                         if (c >= occupied[r].length) continue;
                         if (r > rIdx || c > cIdx) occupied[r][c] = true;
                    }
                }
            } catch (IllegalArgumentException e) { log.warn("Could not add merged region at row {}, col {} ({}x{}). Overlap or invalid range? {}", rIdx, cIdx, rowspan, colspan, e.getMessage());
            } catch (Exception e) { log.error("Error handling merged region at row {}, col {}", rIdx, cIdx, e); }
        }
    }

    // --- Style Application Helpers ---
    private boolean applyTextAlign(XSSFCellStyle style, String value) {
        HorizontalAlignment current = style.getAlignment(); HorizontalAlignment next = current;
        if ("center".equals(value)) next = HorizontalAlignment.CENTER;
        else if ("right".equals(value)) next = HorizontalAlignment.RIGHT;
        else if ("left".equals(value)) next = HorizontalAlignment.LEFT;
        else if ("justify".equals(value)) next = HorizontalAlignment.JUSTIFY;
        if (next != current) { style.setAlignment(next); return true; } return false;
    }

    private boolean applyVerticalAlign(XSSFCellStyle style, String value) {
        VerticalAlignment current = style.getVerticalAlignment(); VerticalAlignment next = current;
        if ("middle".equals(value)) next = VerticalAlignment.CENTER;
        else if ("top".equals(value)) next = VerticalAlignment.TOP;
        else if ("bottom".equals(value)) next = VerticalAlignment.BOTTOM;
        if (next != current) { style.setVerticalAlignment(next); return true; } return false;
    }

    private boolean applyBackgroundColor(XSSFCellStyle style, String value) {
        XSSFColor bgColor = parseColor(value);
        if (bgColor != null) { style.setFillForegroundColor(bgColor); style.setFillPattern(FillPatternType.SOLID_FOREGROUND); return true; } return false;
    }

    private boolean applyFontColor(XSSFFont font, String value) {
        XSSFColor fontColor = parseColor(value); XSSFColor currentColor = font.getXSSFColor();
        if (fontColor != null && !fontColor.equals(currentColor)) { font.setColor(fontColor); return true; } return false;
    }

    private boolean applyFontWeight(XSSFFont font, String value) {
        boolean original = font.getBold(); boolean next = ("bold".equals(value) || "700".equals(value) || "800".equals(value) || "900".equals(value));
        if (next != original) { font.setBold(next); return true; } return false;
    }

     private boolean applyFontStyle(XSSFFont font, String value) {
        boolean original = font.getItalic(); boolean next = ("italic".equals(value) || "oblique".equals(value));
        if (next != original) { font.setItalic(next); return true; } return false;
     }

    // --- Font Size Parsing Helper ---
    private boolean parseFontSize(String value, XSSFFont font) {
        short originalSize = font.getFontHeightInPoints(); short points = -1;
        try {
            if (value.endsWith("pt")) points = Short.parseShort(value.substring(0, value.length() - 2).trim());
            else if (value.endsWith("px")) points = (short) Math.max(1, Math.round(Integer.parseInt(value.substring(0, value.length() - 2).trim()) * 0.75));
            else if (NumberUtils.isDigits(value)) points = Short.parseShort(value);
            else { switch(value) { case "xx-small": points = 6; break; case "x-small": points = 7; break; case "small": points = 8; break; case "medium": points = 10; break; case "large": points = 12; break; case "x-large": points = 14; break; case "xx-large": points = 18; break; } }
            if (points > 0 && points != originalSize) { font.setFontHeightInPoints(points); return true; }
        } catch (Exception e) { log.warn("Could not parse font-size: '{}'. Error: {}", value, e.getMessage()); } return false;
    }

    // --- Font Family Parsing Helper ---
    private boolean parseFontFamily(String value, XSSFFont font) {
        String originalName = font.getFontName(); String finalName = originalName;
        try {
            String[] families = value.split(","); if (families.length > 0) { String firstFamily = StringUtils.strip(families[0].trim(), "'\"");
            if (!"serif".equalsIgnoreCase(firstFamily) && !"sans-serif".equalsIgnoreCase(firstFamily) && !"monospace".equalsIgnoreCase(firstFamily) && !"cursive".equalsIgnoreCase(firstFamily) && !"fantasy".equalsIgnoreCase(firstFamily) && StringUtils.isNotBlank(firstFamily)) { finalName = firstFamily; }}
        } catch (Exception e) { log.warn("Could not parse font-family: '{}'. Error: {}", value, e.getMessage()); return false; }
        if (!StringUtils.equals(finalName, originalName)) { font.setFontName(finalName); return true; } return false;
    }

    // --- Text Decoration Parsing Helper ---
     private boolean parseTextDecoration(String value, XSSFFont font) {
         boolean changed = false; byte currentUnderline = font.getUnderline(); boolean currentStrike = font.getStrikeout();
         byte nextUnderline = Font.U_NONE; boolean nextStrike = false;
         if (value.contains("underline")) nextUnderline = Font.U_SINGLE;
         if (value.contains("line-through")) nextStrike = true;
         if (nextUnderline != currentUnderline) { font.setUnderline(nextUnderline); changed = true; }
         if (nextStrike != currentStrike) { font.setStrikeout(nextStrike); changed = true; } return changed;
     }

    // --- Border Parsing Helpers ---
    private static class BorderSettings { BorderStyle style = BorderStyle.NONE; XSSFColor color = null; }
    private boolean parseGeneralBorder(String value, XSSFCellStyle style) {
        BorderSettings settings = parseBorderSettings(value);
        if (settings != null) { style.setBorderTop(settings.style); style.setTopBorderColor(settings.color); style.setBorderBottom(settings.style); style.setBottomBorderColor(settings.color); style.setBorderLeft(settings.style); style.setLeftBorderColor(settings.color); style.setBorderRight(settings.style); style.setRightBorderColor(settings.color); return true; } return false;
    }
    private boolean parseSpecificBorder(String value, XSSFCellStyle style, BorderSide side) {
         BorderSettings settings = parseBorderSettings(value); BorderStyle styleToSet = BorderStyle.NONE; XSSFColor colorToSet = null;
         if(settings != null) { styleToSet = settings.style; colorToSet = settings.color; }
         switch(side) { case TOP: style.setBorderTop(styleToSet); style.setTopBorderColor(colorToSet); break; case BOTTOM: style.setBorderBottom(styleToSet); style.setBottomBorderColor(colorToSet); break; case LEFT: style.setBorderLeft(styleToSet); style.setLeftBorderColor(colorToSet); break; case RIGHT: style.setBorderRight(styleToSet); style.setRightBorderColor(colorToSet); break; } return settings != null;
    }
    private BorderSettings parseBorderSettings(String value) {
        if (StringUtils.isBlank(value) || "none".equals(value.trim())) return new BorderSettings(); BorderSettings settings = new BorderSettings(); settings.style = BorderStyle.NONE;
        String[] parts = value.split("\\s+");
        for (String part : parts) { if (StringUtils.isBlank(part)) continue; if (settings.color == null) { XSSFColor parsedColor = parseColor(part); if (parsedColor != null) { settings.color = parsedColor; continue; }} BorderStyle parsedStyle = mapCssBorderStyle(part); if (parsedStyle != BorderStyle.NONE) { settings.style = parsedStyle; continue; }}
        if (settings.style != BorderStyle.NONE && settings.color == null) settings.color = new XSSFColor(IndexedColors.BLACK.getIndexed(), new DefaultIndexedColorMap());
        if (settings.style == BorderStyle.NONE && settings.color != null) settings.style = BorderStyle.THIN; return settings; // Return settings even if NONE was specified
    }
    private BorderStyle mapCssBorderStyle(String cssStyle) {
         switch (cssStyle) { case "solid": return BorderStyle.THIN; case "dashed": return BorderStyle.DASHED; case "dotted": return BorderStyle.DOTTED; case "double": return BorderStyle.DOUBLE; case "groove": return BorderStyle.GROOVE; case "ridge": return BorderStyle.RIDGE; case "inset": return BorderStyle.INSET; case "outset": return BorderStyle.OUTSET; case "thin": return BorderStyle.THIN; case "medium": return BorderStyle.MEDIUM; case "thick": return BorderStyle.THICK; case "hidden": case "none": default: return BorderStyle.NONE; }
    }

    // --- Color Parsing Helper ---
    private XSSFColor parseColor(String colorStr) {
         if (StringUtils.isBlank(colorStr)) return null; colorStr = colorStr.toLowerCase().trim(); byte[] rgb = null; IndexedColorMap colorMap = new DefaultIndexedColorMap();
        try { if (colorStr.startsWith("#")) { String hex = colorStr.substring(1); if (hex.length() == 3) hex = "" + hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2); if (hex.length() == 6) { rgb = new byte[]{ (byte)Integer.parseInt(hex.substring(0, 2), 16), (byte)Integer.parseInt(hex.substring(2, 4), 16), (byte)Integer.parseInt(hex.substring(4, 6), 16) }; }}
            else if (colorStr.startsWith("rgb(")) { String[] parts = colorStr.substring(4, colorStr.length() - 1).split(","); if (parts.length == 3) { rgb = new byte[]{ (byte) constrain(Integer.parseInt(parts[0].trim())), (byte) constrain(Integer.parseInt(parts[1].trim())), (byte) constrain(Integer.parseInt(parts[2].trim())) }; }}
            else { rgb = mapColorNameToRgb(colorStr); }
        } catch (Exception e) { log.warn("Could not parse color string: '{}'. Error: {}", colorStr, e.getMessage()); return null; }
        if (rgb != null) { try { return new XSSFColor(rgb, colorMap); } catch (Exception e) { log.warn("Failed to create XSSFColor from RGB for '{}'. Error: {}", colorStr, e.getMessage()); return null; }} return null;
    }
    private byte[] mapColorNameToRgb(String name) {
        switch (name) { case "black": return new byte[]{0, 0, 0}; case "white": return new byte[]{(byte)255, (byte)255, (byte)255}; case "red": return new byte[]{(byte)255, 0, 0}; case "lime": return new byte[]{0, (byte)255, 0}; case "green": return new byte[]{0, (byte)128, 0}; case "blue": return new byte[]{0, 0, (byte)255}; case "yellow": return new byte[]{(byte)255, (byte)255, 0}; case "cyan": case "aqua": return new byte[]{0, (byte)255, (byte)255}; case "magenta": case "fuchsia": return new byte[]{(byte)255, 0, (byte)255}; case "silver": return new byte[]{(byte)192, (byte)192, (byte)192}; case "gray": case "grey": return new byte[]{(byte)128, (byte)128, (byte)128}; case "maroon": return new byte[]{(byte)128, 0, 0}; case "olive": return new byte[]{(byte)128, (byte)128, 0}; case "purple": return new byte[]{(byte)128, 0, (byte)128}; case "teal": return new byte[]{0, (byte)128, (byte)128}; case "navy": return new byte[]{0, 0, (byte)128}; case "transparent": return null; default: return null; }
    }
    private int constrain(int value) { return Math.max(0, Math.min(255, value)); }

    // --- Helper to generate a unique key for font caching ---
    private String generateFontKey(XSSFFont font) {
        XSSFColor color = font.getXSSFColor(); String colorHex = "auto";
        if (color != null && color.isRGB() && color.hasTint() == 0.0) { try { colorHex = color.getARGBHex(); } catch (Exception e) { /* fallback */ }}
        return String.format("%s|%d|%s|%b|%b|%b|%d|%d", font.getFontName(), font.getFontHeightInPoints(), colorHex, font.getBold(), font.getItalic(), font.getStrikeout(), font.getUnderline(), font.getTypeOffset());
    }

}
```

**关键修正点:**

1.  **`createAndCacheStyleFromHtml` 核心修改:**
    * 增加了优先从 `<td>`/`<th>` 内部的第一个 `<span>` 获取 `style` 属性的逻辑。
    * 调用新的 `cleanAndDecodeStyleAttribute` 辅助方法来处理原始 `style` 属性字符串。
    * 使用清理和解码后的 `cleanedStyleAttr` 进行后续的 CSS 解析和缓存 key 生成。
2.  **`cleanAndDecodeStyleAttribute` 新增方法:** 这个方法负责：
    * 去除首尾空格。
    * 移除可能包裹 CSS 声明的 `&quot;` 或 `"`。
    * 使用 `org.jsoup.parser.Parser.unescapeEntities(cleaned, false)` 对内部的 HTML 实体进行解码。
3.  **其余逻辑:** 其他所有辅助方法（如颜色解析、字体解析、边框解析、单元格值设置、合并单元格处理、列宽计算等）保持不变，因为它们现在接收的是清理和解码后的标准 CSS 声明字符串。

现在，这个服务应该能够正确处理您描述的那种 `style` 属性中包含转义引号的情况，并优先考虑内部 `<span>` 的样式，从而更准确地提取和应用样式到生成的 XLSX 文件中。