Okay, let's refine the service to specifically handle a text file containing HTML, target **only the outermost `<table>` tag**, and convert its contents into an XLSX file, preserving inline styles as best as possible.

This version uses Jsoup to parse the HTML fragment provided in the text file, selects the first `<table>` element it finds within the body, and processes that table into a single sheet in the generated XLSX file.

**1. Dependencies (Ensure these are in `pom.xml`)**

```xml
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.5</version> </dependency>
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.17.2</version> </dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.14.0</version> </dependency>
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.16.1</version> </dependency>
```

**2. Rewritten `ExcelConversionService.java`**

```java
package com.example.htmltoxlsx.service; // Adjust package name as needed

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI (XSSF for .xlsx output) imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.DefaultIndexedColorMap;
import org.apache.poi.xssf.usermodel.extensions.XSSFCellBorder.BorderSide;
import org.apache.poi.ss.util.WorkbookUtil; // For safe sheet names

// Jsoup (HTML Parsing) imports
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets; // Specify Charset
import java.util.HashMap;
import java.util.Map;
import java.awt.Color; // Using AWT Color for parsing CSS colors

// Commons IO / Lang imports
import org.apache.commons.io.IOUtils; // For reading InputStream to String
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.lang3.StringUtils;


@Service
@Slf4j
public class ExcelConversionService {

    // --- Caches for Performance ---
    // Cache styles based on the inline style string
    private final Map<String, XSSFCellStyle> htmlStyleCache = new HashMap<>();
    // Cache fonts based on their combined properties
    private final Map<String, XSSFFont> htmlFontCache = new HashMap<>();

    // --- Limits to prevent OutOfMemoryErrors ---
    private static final int MAX_SUPPORTED_ROWS = 100000; // Max rows to process from HTML
    private static final int MAX_SUPPORTED_COLS = 200;    // Max columns to process

    /**
     * Converts an HTML table structure (provided as text) into an XLSX file.
     * It processes the content within the *first* <table> tag found.
     * Attempts to preserve basic inline styles (colors, fonts, alignment, borders).
     *
     * @param file MultipartFile containing the HTML table text.
     * @return Byte array representing the generated XLSX file.
     * @throws IOException If an IO error occurs or the input is invalid.
     */
    public byte[] convertOuterHtmlTableToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }

        String originalFilename = file.getOriginalFilename();
        log.info("Attempting conversion of HTML table from file ({}) to XLSX format.", originalFilename);

        // Clear caches for this specific conversion request
        htmlStyleCache.clear();
        htmlFontCache.clear();

        try (InputStream inputStream = file.getInputStream();
             XSSFWorkbook workbook = new XSSFWorkbook(); // Create target XLSX workbook
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            // --- Read HTML Content from File ---
            String htmlContent = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
            if (StringUtils.isBlank(htmlContent)) {
                 log.warn("Input file {} is empty or contains only whitespace.", originalFilename);
                 throw new IllegalArgumentException("Input file contains no processable content.");
            }

            // --- Jsoup HTML Parsing (as Body Fragment) ---
            // This handles snippets that don't form a full HTML document
            Document doc = Jsoup.parseBodyFragment(htmlContent);
            log.debug("Parsed input stream as HTML body fragment.");

            // --- Select the First (Outermost) Table ---
            // Jsoup wraps fragments in <html><body>...</body></html>, so select table within body.
            Element table = doc.body().selectFirst("table");
            if (table == null) {
                log.error("No <table> element found within the provided HTML content from file: {}", originalFilename);
                throw new IllegalArgumentException("The provided content does not contain a valid HTML table structure.");
            }
            log.debug("Found the first HTML table element to process.");

            // --- Process the Single Table into "Sheet1" ---
            String sheetName = "Sheet1"; // Default sheet name
            XSSFSheet sheet = workbook.createSheet(sheetName);
            log.debug("Processing HTML table into sheet '{}'", sheetName);

            processHtmlTableToSheet(table, sheet, workbook); // Reuse the processing logic

            // --- Write XLSX to Output Stream ---
            workbook.write(baos);
            log.info("Successfully converted HTML table from {} to XLSX format (Sheet: '{}').", originalFilename, sheetName);
            return baos.toByteArray();

        } catch (IOException ioe) {
            log.error("IO Error during HTML to XLSX conversion for file: {}", originalFilename, ioe);
            throw ioe; // Re-throw IOExceptions
        } catch (OutOfMemoryError oom) {
            // Catch OOM specifically if HTML is extremely large
            log.error("OutOfMemoryError during conversion for file: {}. Input HTML might be too large.", originalFilename, oom);
            throw new IOException("Conversion failed due to excessive memory usage. The input HTML may be too large.", oom);
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            log.error("Unexpected error during HTML to XLSX conversion for file: {}", originalFilename, e);
            throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e);
        } finally {
            // Ensure caches are cleared
            htmlStyleCache.clear();
            htmlFontCache.clear();
        }
    }

    // --- Processes a single HTML table element into an XSSFSheet ---
    // (This method remains largely the same as the previous HTML->XLSX version)
    private void processHtmlTableToSheet(Element table, XSSFSheet sheet, XSSFWorkbook workbook) {
        Elements rows = table.select("tr"); // Select rows directly within the target table
        int rowIndex = 0;
        // Occupancy grid for rowspan handling (size dynamically or use large estimate)
        boolean[][] cellOccupied = new boolean[Math.min(rows.size(), MAX_SUPPORTED_ROWS) + 5][MAX_SUPPORTED_COLS + 5];
        // Track max characters per column for width estimation
        Map<Integer, Integer> columnMaxChars = new HashMap<>();

        for (Element row : rows) {
             if (rowIndex >= MAX_SUPPORTED_ROWS) {
                 log.warn("Maximum supported rows ({}) exceeded for sheet '{}'. Skipping remaining rows.", MAX_SUPPORTED_ROWS, sheet.getSheetName());
                 break;
             }

            XSSFRow xssfRow = sheet.createRow(rowIndex);
            Elements cells = row.select("th, td"); // Select cells within this row
            int currentCellIndex = 0;

            for (Element cell : cells) {
                // Skip columns already occupied by a rowspan from a previous row
                while (currentCellIndex < MAX_SUPPORTED_COLS && cellOccupied[rowIndex][currentCellIndex]) {
                    currentCellIndex++;
                }
                // Stop processing row if max columns exceeded
                if (currentCellIndex >= MAX_SUPPORTED_COLS) {
                     log.warn("Maximum supported columns ({}) exceeded at row {} on sheet '{}'. Skipping remaining cells in this row.", MAX_SUPPORTED_COLS, rowIndex, sheet.getSheetName());
                     break;
                }

                XSSFCell xssfCell = xssfRow.createCell(currentCellIndex);
                String cellText = cell.text();

                // --- Cell Value ---
                setCellValue(xssfCell, cellText);
                updateMaxChars(columnMaxChars, currentCellIndex, cellText);

                // --- Cell Style (from inline style attr) ---
                XSSFCellStyle xssfStyle = createAndCacheStyleFromHtml(cell, workbook);
                if (xssfStyle != null) {
                     xssfCell.setCellStyle(xssfStyle);
                }

                // --- Merged Regions (colspan/rowspan) ---
                int colspan = NumberUtils.toInt(cell.attr("colspan"), 1);
                int rowspan = NumberUtils.toInt(cell.attr("rowspan"), 1);
                // Clamp rowspan/colspan to avoid exceeding limits
                rowspan = Math.min(rowspan, MAX_SUPPORTED_ROWS - rowIndex);
                colspan = Math.min(colspan, MAX_SUPPORTED_COLS - currentCellIndex);
                handleMergedRegions(sheet, cellOccupied, rowIndex, currentCellIndex, rowspan, colspan);

                // Move to next logical cell index based on colspan
                currentCellIndex += colspan;
            }
            rowIndex++;
        }
        // --- Apply Estimated Column Widths After Processing ---
        applyColumnWidths(sheet, columnMaxChars);
    }


    // --- Helper: Update max characters seen for a column ---
    private void updateMaxChars(Map<Integer, Integer> maxCharsMap, int colIndex, String text) {
        int length = (text != null) ? text.length() : 0;
        // Consider cell type? Numeric formatting can affect width. Basic length for now.
        maxCharsMap.put(colIndex, Math.max(length, maxCharsMap.getOrDefault(colIndex, 0)));
    }

    // --- Helper: Apply estimated column widths ---
    private void applyColumnWidths(XSSFSheet sheet, Map<Integer, Integer> maxCharsMap) {
         // Constants for width calculation (adjust as needed)
         final int charWidthFactor = 256; // Standard Excel unit factor
         final int padding = 2;           // Add characters for padding
         final double defaultCharWidthApproximation = 1.0; // Approximation for avg char width
         final int minWidthChars = 8;     // Minimum width in characters
         final int maxWidthChars = 100;   // Max characters to consider for width calculation
         final int excelMaxWidthUnits = 255 * charWidthFactor; // Absolute max width

        log.debug("Applying estimated column widths for sheet '{}'", sheet.getSheetName());
        for (Map.Entry<Integer, Integer> entry : maxCharsMap.entrySet()) {
             int colIndex = entry.getKey();
             int maxChars = entry.getValue();
             int clampedMaxChars = Math.min(maxChars, maxWidthChars); // Clamp length consideration

             // Calculate width in Excel units
             int width = (int) ((clampedMaxChars + padding) * defaultCharWidthApproximation * charWidthFactor);
             width = Math.max(width, minWidthChars * charWidthFactor); // Ensure minimum width
             width = Math.min(width, excelMaxWidthUnits); // Ensure maximum width

             try {
                 sheet.setColumnWidth(colIndex, width);
             } catch (Exception e) {
                  log.warn("Failed to set width for column {} on sheet '{}'. Error: {}", colIndex, sheet.getSheetName(), e.getMessage());
             }
        }
    }


    // --- Helper: Set cell value with basic type detection ---
    private void setCellValue(XSSFCell cell, String text) {
        if (text == null) {
            cell.setBlank(); return;
        }
        String trimmedText = text.trim();
        // Prioritize boolean check if applicable
        if ("true".equalsIgnoreCase(trimmedText)) { cell.setCellValue(true); return; }
        if ("false".equalsIgnoreCase(trimmedText)) { cell.setCellValue(false); return; }
        // Then check for numbers
        if (NumberUtils.isCreatable(trimmedText)) {
            try {
                cell.setCellValue(Double.parseDouble(trimmedText)); return;
            } catch (NumberFormatException e) { /* Fallback to string */ }
        }
        // Default to string
        cell.setCellValue(trimmedText);
    }

    // --- Helper: Handle Merged Regions ---
    private void handleMergedRegions(XSSFSheet sheet, boolean[][] occupied, int rIdx, int cIdx, int rowspan, int colspan) {
        if (rowspan > 1 || colspan > 1) {
            // Ensure indices stay within reasonable bounds before calculating lastRow/lastCol
            if (rIdx >= MAX_SUPPORTED_ROWS || cIdx >= MAX_SUPPORTED_COLS) return;

            int lastRow = Math.min(rIdx + rowspan - 1, MAX_SUPPORTED_ROWS - 1);
            int lastCol = Math.min(cIdx + colspan - 1, MAX_SUPPORTED_COLS - 1);

            // Ensure calculated range is valid
            if (lastRow < rIdx || lastCol < cIdx) return;

            try {
                CellRangeAddress mergedRegion = new CellRangeAddress(rIdx, lastRow, cIdx, lastCol);
                // It's possible adding a region fails if it overlaps strangely due to complex prior merges
                // Or if the region is invalid (e.g., negative size after clamping)
                sheet.addMergedRegion(mergedRegion);
                log.trace("Added merged region: {}", mergedRegion.formatAsString());

                // Mark occupied cells, checking array bounds robustly
                for (int r = rIdx; r <= lastRow; r++) {
                     if (r >= occupied.length) continue; // Skip row if outside bounds
                    for (int c = cIdx; c <= lastCol; c++) {
                         if (c >= occupied[r].length) continue; // Skip column if outside bounds
                         if (r > rIdx || c > cIdx) { // Don't mark the top-left cell itself
                             occupied[r][c] = true;
                         }
                    }
                }
            } catch (IllegalArgumentException e) {
                 // Log overlap/invalid argument errors specifically
                 log.warn("Could not add merged region at row {}, col {} ({}x{}). Overlap or invalid range? {}", rIdx, cIdx, rowspan, colspan, e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected errors during merge
                log.error("Error handling merged region at row {}, col {}", rIdx, cIdx, e);
            }
        }
    }


    // --- Helper: Create/Cache XSSFCellStyle from HTML inline style attribute ---
    // Returns null if no style attribute or only default styles applied
    private XSSFCellStyle createAndCacheStyleFromHtml(Element cell, XSSFWorkbook workbook) {
        String styleAttr = cell.attr("style");
        if (StringUtils.isBlank(styleAttr)) {
            return null; // No inline style
        }

        // --- Style Cache Lookup ---
        if (htmlStyleCache.containsKey(styleAttr)) {
            return htmlStyleCache.get(styleAttr);
        }

        // --- Style and Font Initialization ---
        XSSFCellStyle style = workbook.createCellStyle();
        // Get default font (index 0) - we'll clone it only if specific font properties are set
        XSSFFont baseFont = workbook.getFontAt((short) 0);
        XSSFFont currentFont = baseFont; // Start assuming we use the base font
        boolean fontNeedsCloning = true; // Flag: only clone once if needed
        boolean fontIsModified = false;  // Track if currentFont differs from baseFont
        boolean styleIsModified = false; // Track if style differs from default

        // Set Excel defaults that differ from common HTML defaults
        style.setWrapText(false); // Excel default is no wrap, override if CSS indicates wrap

        // --- Parse CSS Declarations ---
        String[] declarations = styleAttr.split(";");
        for (String declaration : declarations) {
            if (StringUtils.isBlank(declaration)) continue;
            String[] parts = declaration.split(":", 2);
            if (parts.length != 2) continue;
            String property = parts[0].trim().toLowerCase();
            String value = parts[1].trim().toLowerCase(); // Lowercase value for easier matching

            try {
                // Clone font object ONCE upon first modification attempt
                if (fontNeedsCloning && isFontProperty(property)) {
                    XSSFFont clonedFont = workbook.createFont();
                    clonedFont.cloneStyleFrom(baseFont);
                    currentFont = clonedFont; // Switch to working with the clone
                    fontNeedsCloning = false;
                    fontIsModified = true; // Mark that the font object might be different now
                }

                // Apply relevant styles
                boolean applied = applyCssProperty(property, value, style, currentFont);
                if (applied) {
                    styleIsModified = true; // Mark that some style aspect was set
                    // If a non-font property was applied, styleIsModified is true.
                    // If a font property was applied, fontIsModified will be true (set above).
                }

            } catch (Exception e) {
                 log.warn("Could not parse/apply style property: '{}' with value '{}'. Error: {}", property, value, e.getMessage());
            }
        }

        // --- Final Font Handling ---
        // If the font object was potentially modified, find/cache and set it
        if (fontIsModified) {
            // We might have modified 'currentFont' (which is a clone)
            String fontKey = generateFontKey(currentFont);
            XSSFFont finalFont = htmlFontCache.computeIfAbsent(fontKey, k -> {
                // Check if workbook already has an identical font before adding potentially duplicate
                 XSSFFont existing = workbook.findFont(
                         currentFont.getBold(), currentFont.getXSSFColor(), // Use getXSSFColor() for POI 5+
                         currentFont.getFontHeightInPoints(), currentFont.getFontName(),
                         currentFont.getItalic(), currentFont.getStrikeout(),
                         currentFont.getTypeOffset(), currentFont.getUnderline()
                 );
                 // Return existing if found, otherwise return the font we created/modified
                 return (existing != null) ? existing : currentFont;
            });
            style.setFont(finalFont);
            styleIsModified = true; // Font is part of the style
        }

        // --- Cache and Return ---
        // Only cache and return the style object if it actually differs from defaults
        if (styleIsModified) {
            htmlStyleCache.put(styleAttr, style);
            return style;
        } else {
            return null; // No non-default styles were applied
        }
    }

    // --- Helper to check if a CSS property affects the font ---
    private boolean isFontProperty(String property) {
         return property.startsWith("font-") || property.equals("color") || property.equals("text-decoration");
    }

    // --- Helper to apply a single CSS property ---
    // Returns true if a style or font property was successfully applied
    private boolean applyCssProperty(String property, String value, XSSFCellStyle style, XSSFFont font) {
        boolean applied = false;
        switch (property) {
            // Alignment
            case "text-align": applied = applyTextAlign(style, value); break;
            case "vertical-align": applied = applyVerticalAlign(style, value); break;
            // Background
            case "background-color": applied = applyBackgroundColor(style, value); break;
            // Font
            case "color": applied = applyFontColor(font, value); break;
            case "font-weight": applied = applyFontWeight(font, value); break;
            case "font-style": applied = applyFontStyle(font, value); break;
            case "font-size": applied = parseFontSize(value, font); break;
            case "font-family": applied = parseFontFamily(value, font); break;
            // Text Decoration
            case "text-decoration": applied = parseTextDecoration(value, font); break;
            // Wrapping
            case "white-space": if ("nowrap".equals(value)) style.setWrapText(false); else style.setWrapText(true); applied = true; break;
            // Borders
            case "border": applied = parseGeneralBorder(value, style); break;
            case "border-top": applied = parseSpecificBorder(value, style, BorderSide.TOP); break;
            case "border-bottom": applied = parseSpecificBorder(value, style, BorderSide.BOTTOM); break;
            case "border-left": applied = parseSpecificBorder(value, style, BorderSide.LEFT); break;
            case "border-right": applied = parseSpecificBorder(value, style, BorderSide.RIGHT); break;
             default: break; // Ignore unsupported
        }
        return applied;
    }


    // --- Style Application Helpers (return true if modification occurred) ---

    private boolean applyTextAlign(XSSFCellStyle style, String value) {
        HorizontalAlignment alignment = style.getAlignment(); // Get current
        if ("center".equals(value)) style.setAlignment(HorizontalAlignment.CENTER);
        else if ("right".equals(value)) style.setAlignment(HorizontalAlignment.RIGHT);
        else if ("left".equals(value)) style.setAlignment(HorizontalAlignment.LEFT);
        else if ("justify".equals(value)) style.setAlignment(HorizontalAlignment.JUSTIFY);
        return style.getAlignment() != alignment; // Return true if changed
    }

    private boolean applyVerticalAlign(XSSFCellStyle style, String value) {
        VerticalAlignment alignment = style.getVerticalAlignment();
        if ("middle".equals(value)) style.setVerticalAlignment(VerticalAlignment.CENTER);
        else if ("top".equals(value)) style.setVerticalAlignment(VerticalAlignment.TOP);
        else if ("bottom".equals(value)) style.setVerticalAlignment(VerticalAlignment.BOTTOM);
        return style.getVerticalAlignment() != alignment;
    }

    private boolean applyBackgroundColor(XSSFCellStyle style, String value) {
        XSSFColor bgColor = parseColor(value);
        if (bgColor != null) {
            style.setFillForegroundColor(bgColor);
            style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
            return true;
        }
        return false;
    }

    private boolean applyFontColor(XSSFFont font, String value) {
        XSSFColor fontColor = parseColor(value);
        if (fontColor != null) {
            font.setColor(fontColor);
            return true;
        }
        // Allow setting back to 'auto' maybe? For now, only apply if valid color found.
        return false;
    }

    private boolean applyFontWeight(XSSFFont font, String value) {
        boolean original = font.getBold();
        if ("bold".equals(value) || "700".equals(value) || "800".equals(value) || "900".equals(value)) {
            font.setBold(true);
        } else {
            font.setBold(false); // Set non-bold explicitly
        }
        return font.getBold() != original;
    }

     private boolean applyFontStyle(XSSFFont font, String value) {
        boolean original = font.getItalic();
        if ("italic".equals(value) || "oblique".equals(value)) {
            font.setItalic(true);
        } else {
            font.setItalic(false);
        }
        return font.getItalic() != original;
     }

    // --- Font Size Parsing Helper ---
    private boolean parseFontSize(String value, XSSFFont font) {
        short originalSize = font.getFontHeightInPoints();
        short points = -1;
        try {
            if (value.endsWith("pt")) {
                points = Short.parseShort(value.substring(0, value.length() - 2).trim());
            } else if (value.endsWith("px")) {
                int pixels = Integer.parseInt(value.substring(0, value.length() - 2).trim());
                points = (short) Math.max(1, Math.round(pixels * 0.75)); // Approx px -> pt
            } else if (NumberUtils.isDigits(value)) {
                 points = Short.parseShort(value); // Assume points if no unit
            } else { // Keywords (approximate)
                 switch(value) {
                     case "xx-small": points = 6; break; case "x-small": points = 7; break;
                     case "small": points = 8; break; case "medium": points = 10; break; // Default-ish
                     case "large": points = 12; break; case "x-large": points = 14; break;
                     case "xx-large": points = 18; break;
                 }
            }
            if (points > 0) {
                font.setFontHeightInPoints(points);
            }
        } catch (Exception e) {
            log.warn("Could not parse font-size: '{}'. Error: {}", value, e.getMessage()); return false;
        }
        return font.getFontHeightInPoints() != originalSize;
    }

    // --- Font Family Parsing Helper ---
    private boolean parseFontFamily(String value, XSSFFont font) {
        String originalName = font.getFontName();
        try {
            String[] families = value.split(",");
            if (families.length > 0) {
                String firstFamily = families[0].trim();
                firstFamily = StringUtils.removeStart(firstFamily, "'");
                firstFamily = StringUtils.removeStart(firstFamily, "\"");
                firstFamily = StringUtils.removeEnd(firstFamily, "'");
                firstFamily = StringUtils.removeEnd(firstFamily, "\"");
                // Avoid setting generic fallbacks
                if (!"serif".equals(firstFamily) && !"sans-serif".equals(firstFamily) && !"monospace".equals(firstFamily)
                   && !"cursive".equals(firstFamily) && !"fantasy".equals(firstFamily) && StringUtils.isNotBlank(firstFamily))
                {
                     font.setFontName(firstFamily);
                }
            }
        } catch (Exception e) {
             log.warn("Could not parse font-family: '{}'. Error: {}", value, e.getMessage()); return false;
        }
        return !StringUtils.equals(font.getFontName(), originalName);
    }

    // --- Text Decoration Parsing Helper ---
     private boolean parseTextDecoration(String value, XSSFFont font) {
         boolean changed = false;
         byte originalUnderline = font.getUnderline();
         boolean originalStrike = font.getStrikeout();

         // Reset first? Or apply additively? Reset is simpler.
         font.setUnderline(Font.U_NONE);
         font.setStrikeout(false);

         if (value.contains("underline")) {
             font.setUnderline(Font.U_SINGLE);
         }
         if (value.contains("line-through")) {
             font.setStrikeout(true);
         }
         changed = (font.getUnderline() != originalUnderline || font.getStrikeout() != originalStrike);
         return changed;
     }


    // --- Border Parsing Helpers ---
    private static class BorderSettings { // Simple holder for parsed border props
        BorderStyle style = BorderStyle.NONE;
        XSSFColor color = null;
        // Could add width parsing later if needed
    }

    // Parses 'border: width style color' - very basic
    private boolean parseGeneralBorder(String value, XSSFCellStyle style) {
        BorderSettings settings = parseBorderSettings(value);
        if (settings != null) {
            style.setBorderTop(settings.style); style.setTopBorderColor(settings.color);
            style.setBorderBottom(settings.style); style.setBottomBorderColor(settings.color);
            style.setBorderLeft(settings.style); style.setLeftBorderColor(settings.color);
            style.setBorderRight(settings.style); style.setRightBorderColor(settings.color);
            return true;
        }
        return false;
    }

    // Parses 'border-top/bottom/left/right: width style color'
    private boolean parseSpecificBorder(String value, XSSFCellStyle style, BorderSide side) {
         BorderSettings settings = parseBorderSettings(value);
         if (settings != null) {
             switch(side) {
                 case TOP: style.setBorderTop(settings.style); style.setTopBorderColor(settings.color); break;
                 case BOTTOM: style.setBorderBottom(settings.style); style.setBottomBorderColor(settings.color); break;
                 case LEFT: style.setBorderLeft(settings.style); style.setLeftBorderColor(settings.color); break;
                 case RIGHT: style.setBorderRight(settings.style); style.setRightBorderColor(settings.color); break;
                 // Other sides (DIAGONAL etc.) not handled from CSS
             }
             return true;
         }
         return false;
    }

    // Basic parser for border value string -> settings
    private BorderSettings parseBorderSettings(String value) {
        if (StringUtils.isBlank(value) || "none".equals(value)) return null;
        BorderSettings settings = new BorderSettings();
        String[] parts = value.split("\\s+"); // Split by whitespace

        for (String part : parts) {
            if (StringUtils.isBlank(part)) continue;
            // Try color parse
            if (settings.color == null) {
                 XSSFColor parsedColor = parseColor(part);
                 if (parsedColor != null) { settings.color = parsedColor; continue; }
            }
            // Try style parse
            BorderStyle parsedStyle = mapCssBorderStyle(part);
            if (parsedStyle != BorderStyle.NONE) { settings.style = parsedStyle; continue; }
            // Could add width parsing here ("1px", "thin", "medium") and map to style thickness
        }
        // Default style to THIN if only color was found? Or require style keyword? Require style keyword.
        // Default color to black if style was found but no color
        if (settings.style != BorderStyle.NONE && settings.color == null) {
            settings.color = new XSSFColor(IndexedColors.BLACK.getIndexed(), new DefaultIndexedColorMap());
        }
        return (settings.style != BorderStyle.NONE) ? settings : null;
    }

    // Map CSS border style names to POI BorderStyle enum
    private BorderStyle mapCssBorderStyle(String cssStyle) {
        // (Same mapping as previous versions)
         switch (cssStyle) {
             case "solid": return BorderStyle.THIN; case "dashed": return BorderStyle.DASHED;
             case "dotted": return BorderStyle.DOTTED; case "double": return BorderStyle.DOUBLE;
             case "groove": return BorderStyle.GROOVE; case "ridge": return BorderStyle.RIDGE;
             case "inset": return BorderStyle.INSET; case "outset": return BorderStyle.OUTSET;
             case "thin": return BorderStyle.THIN; case "medium": return BorderStyle.MEDIUM;
             case "thick": return BorderStyle.THICK;
             case "hidden": case "none": default: return BorderStyle.NONE;
         }
    }


    // --- Color Parsing Helper ---
    private XSSFColor parseColor(String colorStr) {
         if (StringUtils.isBlank(colorStr)) return null;
         colorStr = colorStr.toLowerCase().trim();
         byte[] rgb = null;
         IndexedColorMap colorMap = new DefaultIndexedColorMap(); // Use default map

        try {
            // Hex: #RRGGBB or #RGB
            if (colorStr.startsWith("#")) {
                String hex = colorStr.substring(1);
                if (hex.length() == 3) hex = "" + hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
                if (hex.length() == 6) {
                     rgb = new byte[]{ (byte)Integer.parseInt(hex.substring(0, 2), 16),
                                       (byte)Integer.parseInt(hex.substring(2, 4), 16),
                                       (byte)Integer.parseInt(hex.substring(4, 6), 16) };
                }
            }
            // RGB: rgb(r, g, b)
            else if (colorStr.startsWith("rgb(")) {
                 String[] parts = colorStr.substring(4, colorStr.length() - 1).split(",");
                 if (parts.length == 3) {
                     rgb = new byte[]{ (byte) constrain(Integer.parseInt(parts[0].trim())),
                                       (byte) constrain(Integer.parseInt(parts[1].trim())),
                                       (byte) constrain(Integer.parseInt(parts[2].trim())) };
                 }
            }
            // Color Names (Basic Map)
            else { rgb = mapColorNameToRgb(colorStr); }
        } catch (Exception e) {
             log.warn("Could not parse color string: '{}'. Error: {}", colorStr, e.getMessage()); return null;
        }

        if (rgb != null) {
             try { return new XSSFColor(rgb, colorMap); } // Create XSSFColor
             catch (Exception e) { log.warn("Failed to create XSSFColor from RGB for '{}'.", colorStr, e); return null; }
        }
        return null;
    }

    // Map common CSS color names to RGB byte arrays
    private byte[] mapColorNameToRgb(String name) {
        // (Same map as previous versions)
        switch (name) {
            case "black": return new byte[]{0, 0, 0}; case "white": return new byte[]{(byte)255, (byte)255, (byte)255};
            case "red": return new byte[]{(byte)255, 0, 0}; case "lime": return new byte[]{0, (byte)255, 0};
            case "green": return new byte[]{0, (byte)128, 0}; case "blue": return new byte[]{0, 0, (byte)255};
            case "yellow": return new byte[]{(byte)255, (byte)255, 0}; case "cyan": case "aqua": return new byte[]{0, (byte)255, (byte)255};
            case "magenta": case "fuchsia": return new byte[]{(byte)255, 0, (byte)255}; case "silver": return new byte[]{(byte)192, (byte)192, (byte)192};
            case "gray": case "grey": return new byte[]{(byte)128, (byte)128, (byte)128}; case "maroon": return new byte[]{(byte)128, 0, 0};
            case "olive": return new byte[]{(byte)128, (byte)128, 0}; case "purple": return new byte[]{(byte)128, 0, (byte)128};
            case "teal": return new byte[]{0, (byte)128, (byte)128}; case "navy": return new byte[]{0, 0, (byte)128};
            default: return null;
        }
    }

    // Constrain integer to byte range 0-255
    private int constrain(int value) { return Math.max(0, Math.min(255, value)); }

    // --- Helper to generate a unique key for font caching ---
    private String generateFontKey(XSSFFont font) {
        // Use ARGB hex for color part of key for better uniqueness
        XSSFColor color = font.getXSSFColor();
        String colorHex = (color != null && color.hasTint() == 0.0 && color.isRGB()) ? color.getARGBHex() : "auto"; // Use Hex if available and not tinted

        return String.format("%s|%d|%s|%b|%b|%b|%d|%d",
                font.getFontName(), font.getFontHeightInPoints(), colorHex,
                font.getBold(), font.getItalic(), font.getStrikeout(),
                font.getUnderline(), font.getTypeOffset()
        );
    }
}
```

**主要变化和改进:**

1.  **输入处理:** 使用 `IOUtils.toString` 读取输入流为字符串，然后用 `Jsoup.parseBodyFragment` 解析HTML片段。
2.  **表格选择:** 使用 `doc.body().selectFirst("table")` 来明确选择解析后的body中的第一个（通常就是最外层的）表格元素。添加了错误处理，如果找不到表格则抛出异常。
3.  **单Sheet处理:** 移除了处理多个表格和生成多个Sheet的逻辑，现在固定将找到的第一个表格处理到 "Sheet1" 中。
4.  **核心逻辑保留:** 数据提取、样式解析（包括新增的字体大小、名称、边框、换行等）、合并单元格处理、列宽估算等核心逻辑都基于之前的最佳实践版本。
5.  **健壮性:** 添加了对行数和列数的限制 (`MAX_SUPPORTED_ROWS`, `MAX_SUPPORTED_COLS`)，以防止处理过大的HTML表格导致内存溢出，并对超出范围的情况添加了日志警告。在合并单元格和列宽设置中也增加了边界检查。
6.  **代码结构:** 保持了将样式应用、颜色解析、字体解析等分解为辅助方法的结构。
7.  **缓存:** 保留了基于内联样式字符串的 `XSSFCellStyle` 缓存和基于字体属性组合的 `XSSFFont` 缓存，以提高性能。

这个版本现在应该能够准确地处理您描述的输入（包含 `<table>` 内容的文本文件），提取最外层表格的数据和尽可能多的内联样式，并生成一个对应的 XLSX 文件。