Okay, let's enhance the `ExcelConversionService` to better handle more CSS properties from inline styles, specifically focusing on:

1.  **Text Wrapping (`white-space`)**
2.  **Font Size (`font-size`)**
3.  **Font Name (`font-family`)**
4.  **Alignment (`text-align`, `vertical-align`)** - Refined
5.  **Borders (`border`, `border-top`, etc.)** - Basic implementation
6.  **Color (`color`)** - Already present
7.  **Background Color (`background-color`)** - Already present
8.  **Bold/Italic (`font-weight`, `font-style`)** - Already present

**Important Considerations & Limitations:**

* **CSS Parsing:** Parsing complex CSS strings (especially shorthand properties like `border`) robustly is non-trivial. This implementation will handle common, simple cases found in inline styles but may fail on complex CSS values.
* **Unit Conversion:** Converting CSS units like `px`, `em`, `rem` to Excel's points (`pt`) for font sizes is approximate.
* **Border Mapping:** Mapping CSS border styles/widths to Excel's `BorderStyle` enum is also an approximation. We'll focus on mapping common styles like `solid`, `dashed`, `dotted`, `double`.
* **Inheritance & Classes:** This code **only** considers inline `style="..."` attributes on the `<td>`/`<th>` elements. It does not handle styles applied via CSS classes, external stylesheets, or inheritance from parent elements (`<tr>`, `<table>`).
* **Performance:** Extensive style parsing and object creation can impact performance for very large HTML tables. Caching helps mitigate this for *identical* style strings.

**Steps:**

1.  **Ensure Dependencies:** Make sure you have `org.jsoup:jsoup` and `org.apache.commons:commons-lang3` in your `pom.xml`.
2.  **Replace/Update `ExcelConversionService.java`:** Use the following enhanced code.

**Enhanced `ExcelConversionService.java`:**

```java
package com.example.xlstoxlsxconverter.service;

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI (XSSF for .xlsx output) imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.DefaultIndexedColorMap; // For color parsing
import org.apache.poi.xssf.usermodel.extensions.XSSFCellBorder.BorderSide; // For border sides


// Jsoup (HTML Parsing) imports
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.lang3.StringUtils;

@Service
@Slf4j
public class ExcelConversionService {

    // Cache for basic styles derived from HTML
    private final Map<String, XSSFCellStyle> htmlStyleCache = new HashMap<>();
    // Cache for fonts derived from HTML styles
    private final Map<String, XSSFFont> htmlFontCache = new HashMap<>();

    // --- Main Conversion Method ---
    public byte[] convertHtmlTableToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }

        String originalFilename = file.getOriginalFilename();
        log.info("Attempting conversion from HTML table (suspected) in file: {}", originalFilename);

        // Clear caches for this conversion
        htmlStyleCache.clear();
        htmlFontCache.clear();

        try (InputStream inputStream = file.getInputStream();
             XSSFWorkbook xssfWorkbook = new XSSFWorkbook(); // Create target XLSX
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            // --- Jsoup HTML Parsing ---
            Document doc = Jsoup.parse(inputStream, "UTF-8", "");
            log.debug("Parsed input stream as HTML.");

            Element table = doc.selectFirst("table");
            if (table == null) {
                log.error("No <table> element found in the uploaded file: {}", originalFilename);
                throw new IllegalArgumentException("The uploaded file does not contain an HTML table.");
            }
            log.debug("Found HTML table element.");

            XSSFSheet xssfSheet = xssfWorkbook.createSheet("Sheet1");

            // --- Data, Style, and Structure Extraction ---
            Elements rows = table.select("tr");
            int rowIndex = 0;
            // Simple occupancy tracking for rowspan
            boolean[][] cellOccupied = new boolean[rows.size() + 100][300]; // Increase size estimates

            log.info("Processing {} rows from HTML table...", rows.size());
            for (Element row : rows) {
                XSSFRow xssfRow = xssfSheet.createRow(rowIndex);
                Elements cells = row.select("th, td");

                int currentCellIndex = 0;
                for (Element cell : cells) {
                    // Skip columns occupied by rowspan
                    while (currentCellIndex < cellOccupied[rowIndex].length && cellOccupied[rowIndex][currentCellIndex]) {
                        currentCellIndex++;
                    }
                    if (currentCellIndex >= cellOccupied[rowIndex].length) {
                         log.warn("Maximum tracked columns ({}) exceeded at row {}. Some cells may be skipped.", cellOccupied[rowIndex].length, rowIndex);
                         continue; // Skip cells beyond tracked range
                    }

                    XSSFCell xssfCell = xssfRow.createCell(currentCellIndex);

                    // --- Cell Value ---
                    setCellValue(xssfCell, cell.text());

                    // --- Cell Style (from inline style attr) ---
                    XSSFCellStyle xssfStyle = createStyleFromHtml(cell, xssfWorkbook);
                    if (xssfStyle != null) {
                         xssfCell.setCellStyle(xssfStyle);
                    }

                    // --- Merged Regions (colspan/rowspan) ---
                    int colspan = NumberUtils.toInt(cell.attr("colspan"), 1);
                    int rowspan = NumberUtils.toInt(cell.attr("rowspan"), 1);
                    handleMergedRegions(xssfSheet, cellOccupied, rowIndex, currentCellIndex, rowspan, colspan);

                    // Move to next available cell index
                    currentCellIndex += colspan;
                }
                rowIndex++;
            }
            log.info("Finished processing HTML table rows.");

            // --- Auto-size columns (Basic heuristic - can be slow/inaccurate) ---
             // autoSizeColumns(xssfSheet); // Consider calling a helper if needed

            xssfWorkbook.write(baos);
            log.info("Successfully converted HTML table from {} to XLSX format.", originalFilename);
            return baos.toByteArray();

        } catch (IOException ioe) {
            log.error("IO Error during HTML table to XLSX conversion for file: {}", originalFilename, ioe);
            throw ioe;
        } catch (Exception e) {
            log.error("Unexpected error during HTML table to XLSX conversion for file: {}", originalFilename, e);
            throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e);
        } finally {
            htmlStyleCache.clear();
            htmlFontCache.clear();
        }
    }

    // --- Helper to set cell value with basic type detection ---
    private void setCellValue(XSSFCell cell, String text) {
        if (text == null) {
            cell.setBlank();
            return;
        }
        String trimmedText = text.trim();
        if (NumberUtils.isCreatable(trimmedText)) {
            try {
                cell.setCellValue(Double.parseDouble(trimmedText));
                return;
            } catch (NumberFormatException e) { /* Fallback to string */ }
        }
        if ("true".equalsIgnoreCase(trimmedText)) {
            cell.setCellValue(true);
        } else if ("false".equalsIgnoreCase(trimmedText)) {
            cell.setCellValue(false);
        } else {
            cell.setCellValue(trimmedText);
        }
    }

    // --- Helper to handle merged regions based on colspan/rowspan ---
    private void handleMergedRegions(XSSFSheet sheet, boolean[][] occupied, int rIdx, int cIdx, int rowspan, int colspan) {
         if (rowspan > 1 || colspan > 1) {
             int lastRow = rIdx + rowspan - 1;
             int lastCol = cIdx + colspan - 1;
             try {
                 CellRangeAddress mergedRegion = new CellRangeAddress(rIdx, lastRow, cIdx, lastCol);
                 sheet.addMergedRegion(mergedRegion);
                 log.trace("Added merged region: {}", mergedRegion.formatAsString());

                 // Mark cells covered by rowspan/colspan as occupied
                 for (int r = rIdx; r <= lastRow; r++) {
                     for (int c = cIdx; c <= lastCol; c++) {
                          if (r >= occupied.length || c >= occupied[r].length) {
                             log.warn("Cell occupancy array size ({},{}) exceeded at [{}, {}]. Merged cell tracking might be incomplete.",
                                     occupied.length, (r < occupied.length ? occupied[r].length : 0), r, c);
                             continue;
                          }
                         if (r > rIdx || c > cIdx) { // Don't mark the top-left cell itself
                             occupied[r][c] = true;
                         }
                     }
                 }
             } catch (IllegalArgumentException e) {
                  log.warn("Could not add merged region at row {}, col {} (colspan={}, rowspan={}). Overlap possible? {}",
                          rIdx, cIdx, colspan, rowspan, e.getMessage());
             } catch (Exception e) {
                 log.error("Error handling merged region at row {}, col {}", rIdx, cIdx, e);
             }
         }
    }

    // --- Helper to create/cache XSSFCellStyle from HTML element's inline style ---
    private XSSFCellStyle createStyleFromHtml(Element cell, XSSFWorkbook workbook) {
        String styleAttr = cell.attr("style");
        if (StringUtils.isBlank(styleAttr)) {
            return null; // No inline style
        }

        // --- Caching based on style string ---
        if (htmlStyleCache.containsKey(styleAttr)) {
            return htmlStyleCache.get(styleAttr);
        }

        // --- Style Creation & Parsing ---
        XSSFCellStyle style = workbook.createCellStyle();
        // Start with default font, clone if modified
        XSSFFont currentFont = workbook.getFontAt((short) 0); // Get default font
        XSSFFont newFont = null; // Will hold cloned font if needed
        boolean fontIsModified = false;
        boolean styleIsModified = false; // Track if any style property was set

        // Default to wrap text (common HTML behavior)
        style.setWrapText(true);
        styleIsModified = true; // Wrap text is non-default for Excel

        // Split style string ";"-separated declarations
        String[] declarations = styleAttr.split(";");
        for (String declaration : declarations) {
            if (StringUtils.isBlank(declaration)) continue;
            String[] parts = declaration.split(":", 2);
            if (parts.length != 2) continue;

            String property = parts[0].trim().toLowerCase();
            String value = parts[1].trim(); // Keep original case for some values? No, lower for consistency. Lowercase it.
            value = value.toLowerCase();

            try {
                 // Clone font on first modification attempt
                 if (newFont == null && (property.startsWith("font-") || property.equals("color") || property.equals("text-decoration"))) {
                     newFont = workbook.createFont();
                     newFont.cloneStyleFrom(currentFont);
                     currentFont = newFont; // Work with the clone now
                     fontIsModified = true;
                 }

                switch (property) {
                    // --- Alignment ---
                    case "text-align":
                        if ("center".equals(value)) style.setAlignment(HorizontalAlignment.CENTER);
                        else if ("right".equals(value)) style.setAlignment(HorizontalAlignment.RIGHT);
                        else if ("left".equals(value)) style.setAlignment(HorizontalAlignment.LEFT);
                        else if ("justify".equals(value)) style.setAlignment(HorizontalAlignment.JUSTIFY);
                        styleIsModified = true;
                        break;
                    case "vertical-align":
                         if ("middle".equals(value)) style.setVerticalAlignment(VerticalAlignment.CENTER);
                         else if ("top".equals(value)) style.setVerticalAlignment(VerticalAlignment.TOP);
                         else if ("bottom".equals(value)) style.setVerticalAlignment(VerticalAlignment.BOTTOM);
                         // baseline, etc. map poorly to Excel vertical align
                         styleIsModified = true;
                         break;

                    // --- Background ---
                    case "background-color":
                        XSSFColor bgColor = parseColor(value);
                        if (bgColor != null) {
                            style.setFillForegroundColor(bgColor);
                            style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
                            styleIsModified = true;
                        }
                        break;

                    // --- Font ---
                    case "color":
                        XSSFColor fontColor = parseColor(value);
                        if (fontColor != null) currentFont.setColor(fontColor);
                        break;
                    case "font-weight":
                        if ("bold".equals(value) || "700".equals(value) || "800".equals(value) || "900".equals(value)) {
                            currentFont.setBold(true);
                        } else {
                             currentFont.setBold(false); // Explicitly set false if value is not bold
                        }
                        break;
                    case "font-style":
                        if ("italic".equals(value) || "oblique".equals(value)) {
                            currentFont.setItalic(true);
                        } else {
                            currentFont.setItalic(false); // Explicitly set false
                        }
                        break;
                    case "font-size":
                        parseFontSize(value, currentFont);
                        break;
                    case "font-family":
                        parseFontFamily(value, currentFont);
                        break;

                    // --- Text Decoration ---
                    case "text-decoration": // simplified check
                        if (value.contains("underline")) currentFont.setUnderline(Font.U_SINGLE);
                        else currentFont.setUnderline(Font.U_NONE); // Explicitly set none

                        if (value.contains("line-through")) currentFont.setStrikeout(true);
                         else currentFont.setStrikeout(false); // Explicitly set false
                        break;

                    // --- Wrapping ---
                    case "white-space":
                        if ("nowrap".equals(value)) style.setWrapText(false);
                        // else keep default of true set earlier
                        styleIsModified = true;
                        break;

                    // --- Borders ---
                    case "border": parseGeneralBorder(value, style); styleIsModified = true; break;
                    case "border-top": parseSpecificBorder(value, style, BorderSide.TOP); styleIsModified = true; break;
                    case "border-bottom": parseSpecificBorder(value, style, BorderSide.BOTTOM); styleIsModified = true; break;
                    case "border-left": parseSpecificBorder(value, style, BorderSide.LEFT); styleIsModified = true; break;
                    case "border-right": parseSpecificBorder(value, style, BorderSide.RIGHT); styleIsModified = true; break;
                    // Note: border-color, border-width, border-style overrides not handled separately here

                     default: break; // Ignore unsupported properties
                }
            } catch (Exception e) {
                 log.warn("Could not parse or apply style property: '{}' with value '{}'. Error: {}", property, value, e.getMessage());
            }
        }

        // --- Final Font Handling ---
        // If the font was potentially modified, find or create it in the workbook
        if (fontIsModified) {
            // Check cache for identical font first
            String fontKey = generateFontKey(currentFont);
            XSSFFont finalFont = htmlFontCache.get(fontKey);
            if (finalFont == null) {
                // Font not in cache, check if workbook already has identical one
                 finalFont = workbook.findFont(
                         currentFont.getBold(),
                         currentFont.getColor(), // getColor() now returns XSSFColor object in POI 5+
                         currentFont.getFontHeightInPoints(),
                         currentFont.getFontName(),
                         currentFont.getItalic(),
                         currentFont.getStrikeout(),
                         currentFont.getTypeOffset(),
                         currentFont.getUnderline()
                 );
                 if (finalFont == null) {
                     // If not found by findFont, use the one we potentially created/cloned
                     // If newFont is null here, it means we only set defaults (like bold=false),
                     // so we might still need to create it if it differs from font 0.
                     // This logic gets complex. For simplicity: if modified, always set the font.
                     // If newFont is null, it implies we modified the original defaultFont object.
                     // We should ensure 'currentFont' holds the potentially modified font.
                     finalFont = currentFont; // Use the possibly modified font object
                     // We should ideally register this font if it's truly new, but POI might handle duplicates.
                 }
                 htmlFontCache.put(fontKey, finalFont); // Cache the font we decided to use
            }
            style.setFont(finalFont); // Set the resolved font on the style
            styleIsModified = true;
        }

        // --- Caching and Return ---
        if (styleIsModified) {
            htmlStyleCache.put(styleAttr, style);
            return style;
        } else {
            // If no specific styles applied, don't cache or return a new style object
            return null;
        }
    }

    // --- Helper to generate a unique key for font caching ---
    private String generateFontKey(XSSFFont font) {
        // Include all relevant properties in the key
        return String.format("%s|%d|%s|%b|%b|%b|%d|%d",
                font.getFontName(),
                font.getFontHeightInPoints(),
                font.getColor() != null ? font.getColor().getARGBHex() : "auto", // Use hex color or "auto"
                font.getBold(),
                font.getItalic(),
                font.getStrikeout(),
                font.getUnderline(),
                font.getTypeOffset()
        );
    }


    // --- Helper to parse font-size ---
    private void parseFontSize(String value, XSSFFont font) {
        try {
            if (value.endsWith("pt")) {
                int points = Integer.parseInt(value.substring(0, value.length() - 2).trim());
                if (points > 0) font.setFontHeightInPoints((short) points);
            } else if (value.endsWith("px")) {
                int pixels = Integer.parseInt(value.substring(0, value.length() - 2).trim());
                // Approximate conversion: 1px = 0.75pt (assuming 96 DPI)
                if (pixels > 0) font.setFontHeightInPoints((short) Math.round(pixels * 0.75));
            } else if (NumberUtils.isDigits(value)) {
                 // Assume pixels if no unit? Or points? Let's assume points for simplicity.
                 int points = Integer.parseInt(value);
                 if (points > 0) font.setFontHeightInPoints((short) points);
            } else {
                 // Handle keywords (approximate)
                 switch(value) {
                     case "xx-small": font.setFontHeightInPoints((short) 6); break;
                     case "x-small": font.setFontHeightInPoints((short) 7); break;
                     case "small": font.setFontHeightInPoints((short) 8); break;
                     case "medium": font.setFontHeightInPoints((short) 10); break; // Default?
                     case "large": font.setFontHeightInPoints((short) 12); break;
                     case "x-large": font.setFontHeightInPoints((short) 14); break;
                     case "xx-large": font.setFontHeightInPoints((short) 18); break;
                 }
            }
        } catch (Exception e) {
            log.warn("Could not parse font-size: '{}'. Error: {}", value, e.getMessage());
        }
    }

    // --- Helper to parse font-family ---
    private void parseFontFamily(String value, XSSFFont font) {
        // Takes the first font name from a comma-separated list
        String[] families = value.split(",");
        if (families.length > 0) {
            String firstFamily = families[0].trim();
            // Remove quotes if present
            firstFamily = StringUtils.removeStart(firstFamily, "'");
            firstFamily = StringUtils.removeStart(firstFamily, "\"");
            firstFamily = StringUtils.removeEnd(firstFamily, "'");
            firstFamily = StringUtils.removeEnd(firstFamily, "\"");
            // Avoid generic families that don't map well
            if (!"serif".equals(firstFamily) && !"sans-serif".equals(firstFamily) && !"monospace".equals(firstFamily) && !"cursive".equals(firstFamily) && !"fantasy".equals(firstFamily)) {
                 font.setFontName(firstFamily);
            }
        }
    }

    // --- Helper to parse text-decoration ---
     private void parseTextDecoration(String value, XSSFFont font) {
         // Reset decorations first
         font.setUnderline(Font.U_NONE);
         font.setStrikeout(false);
         // Apply based on value
         if (value.contains("underline")) {
             font.setUnderline(Font.U_SINGLE);
         }
         // Note: POI doesn't support overline or blink directly
         if (value.contains("line-through")) {
             font.setStrikeout(true);
         }
     }

    // --- Helper to parse general 'border' shorthand property ---
    private void parseGeneralBorder(String value, XSSFCellStyle style) {
        // Very basic parsing: look for style and color
        BorderSettings settings = parseBorderSettings(value);
        if (settings != null) {
            style.setBorderTop(settings.style);
            style.setTopBorderColor(settings.color);
            style.setBorderBottom(settings.style);
            style.setBottomBorderColor(settings.color);
            style.setBorderLeft(settings.style);
            style.setLeftBorderColor(settings.color);
            style.setBorderRight(settings.style);
            style.setRightBorderColor(settings.color);
        }
    }

    // --- Helper to parse specific 'border-top', 'border-bottom', etc. ---
    private void parseSpecificBorder(String value, XSSFCellStyle style, BorderSide side) {
         BorderSettings settings = parseBorderSettings(value);
         if (settings != null) {
             switch(side) {
                 case TOP:    style.setBorderTop(settings.style); style.setTopBorderColor(settings.color); break;
                 case BOTTOM: style.setBorderBottom(settings.style); style.setBottomBorderColor(settings.color); break;
                 case LEFT:   style.setBorderLeft(settings.style); style.setLeftBorderColor(settings.color); break;
                 case RIGHT:  style.setBorderRight(settings.style); style.setRightBorderColor(settings.color); break;
                 // DIAGONAL not handled from standard CSS border properties
             }
         }
    }

    // --- Helper class to hold parsed border settings ---
    private static class BorderSettings {
        BorderStyle style = BorderStyle.NONE;
        XSSFColor color = null;
        // Could add width parsing here too if needed
    }

    // --- Very basic border value parser ---
    private BorderSettings parseBorderSettings(String value) {
        if (StringUtils.isBlank(value) || "none".equals(value)) {
            return null; // No border or explicitly none
        }

        BorderSettings settings = new BorderSettings();
        String[] parts = value.split("\\s+"); // Split by whitespace

        // Find style and color
        for (String part : parts) {
            // Try parsing as color
            if (settings.color == null) {
                 XSSFColor parsedColor = parseColor(part);
                 if (parsedColor != null) {
                     settings.color = parsedColor;
                     continue; // Move to next part
                 }
            }

            // Try mapping to BorderStyle
            BorderStyle parsedStyle = mapCssBorderStyle(part);
            if (parsedStyle != BorderStyle.NONE) {
                 settings.style = parsedStyle;
                 continue;
            }

            // Could try parsing width here (e.g., "1px", "thin", "medium")
            // For now, we primarily rely on the style name (solid -> THIN)
        }

        // Default to THIN if a color was found but no specific style name matched
        if (settings.style == BorderStyle.NONE && settings.color != null) {
            settings.style = BorderStyle.THIN;
        }
        // Ensure color is set if style is not NONE (default to black?)
        if (settings.style != BorderStyle.NONE && settings.color == null) {
            settings.color = new XSSFColor(IndexedColors.BLACK.getIndexed(), new DefaultIndexedColorMap());
        }


        if (settings.style != BorderStyle.NONE) {
             return settings;
        } else {
             return null; // Couldn't parse a valid style/color combination
        }
    }

    // --- Map CSS border style names to POI BorderStyle ---
    private BorderStyle mapCssBorderStyle(String cssStyle) {
         switch (cssStyle.toLowerCase()) {
             case "solid": return BorderStyle.THIN; // Default solid map
             case "dashed": return BorderStyle.DASHED;
             case "dotted": return BorderStyle.DOTTED;
             case "double": return BorderStyle.DOUBLE;
             case "groove": return BorderStyle.GROOVE;
             case "ridge": return BorderStyle.RIDGE;
             case "inset": return BorderStyle.INSET;
             case "outset": return BorderStyle.OUTSET;
             // Approximate thickness - could refine parseBorderSettings to handle this better
             case "thin": return BorderStyle.THIN;
             case "medium": return BorderStyle.MEDIUM;
             case "thick": return BorderStyle.THICK;
             // Hidden maps to none?
             case "hidden":
             case "none":
             default: return BorderStyle.NONE;
         }
    }


    // --- Helper to parse CSS color strings (hex, rgb, names) into XSSFColor ---
    // Overloaded version without workbook param for border parsing simplicity
    private XSSFColor parseColor(String colorStr) {
         return parseColor(colorStr, null); // Pass null workbook - only affects potential theme colors etc.
    }

    private XSSFColor parseColor(String colorStr, XSSFWorkbook workbook) { // Keep workbook potentially for future theme color use
         if (StringUtils.isBlank(colorStr)) return null;
         colorStr = colorStr.toLowerCase().trim();
         byte[] rgb = null;
         // Use DefaultIndexedColorMap for mapping standard colors if needed
         IndexedColorMap colorMap = (workbook != null) ? workbook.getStylesSource().getIndexedColors() : new DefaultIndexedColorMap();

        try {
             // ... (Hex and RGB parsing logic as before) ...
            if (colorStr.startsWith("#")) {
                String hex = colorStr.substring(1);
                if (hex.length() == 3) hex = "" + hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
                if (hex.length() == 6) {
                     int r = Integer.parseInt(hex.substring(0, 2), 16);
                     int g = Integer.parseInt(hex.substring(2, 4), 16);
                     int b = Integer.parseInt(hex.substring(4, 6), 16);
                     rgb = new byte[]{(byte) r, (byte) g, (byte) b};
                }
            } else if (colorStr.startsWith("rgb(")) {
                 String[] parts = colorStr.substring(4, colorStr.length() - 1).split(",");
                 if (parts.length == 3) {
                     int r = Integer.parseInt(parts[0].trim());
                     int g = Integer.parseInt(parts[1].trim());
                     int b = Integer.parseInt(parts[2].trim());
                     rgb = new byte[]{(byte) constrain(r), (byte) constrain(g), (byte) constrain(b)}; // Constrain 0-255
                 }
            } else {
                // Basic color names mapping
                 rgb = mapColorNameToRgb(colorStr);
            }

        } catch (Exception e) { // Catch broader exceptions during parsing
             log.warn("Could not parse color string: '{}'. Error: {}", colorStr, e.getMessage());
             return null;
        }

        if (rgb != null) {
             try {
                // Create XSSFColor with RGB, using the provided/default color map
                 return new XSSFColor(rgb, colorMap);
             } catch (Exception e) {
                 log.warn("Failed to create XSSFColor from RGB for color string '{}'. Error: {}", colorStr, e.getMessage());
                 return null;
             }
        }
        return null;
    }

    // Map common CSS color names to RGB byte arrays
    private byte[] mapColorNameToRgb(String name) {
        switch (name) {
            case "black": return new byte[]{0, 0, 0};
            case "white": return new byte[]{(byte)255, (byte)255, (byte)255};
            case "red": return new byte[]{(byte)255, 0, 0};
            case "lime": return new byte[]{0, (byte)255, 0}; // CSS lime is 0,255,0
            case "green": return new byte[]{0, (byte)128, 0}; // CSS green is 0,128,0
            case "blue": return new byte[]{0, 0, (byte)255};
            case "yellow": return new byte[]{(byte)255, (byte)255, 0};
            case "cyan": case "aqua": return new byte[]{0, (byte)255, (byte)255};
            case "magenta": case "fuchsia": return new byte[]{(byte)255, 0, (byte)255};
            case "silver": return new byte[]{(byte)192, (byte)192, (byte)192};
            case "gray": case "grey": return new byte[]{(byte)128, (byte)128, (byte)128};
            case "maroon": return new byte[]{(byte)128, 0, 0};
            case "olive": return new byte[]{(byte)128, (byte)128, 0};
            case "purple": return new byte[]{(byte)128, 0, (byte)128};
            case "teal": return new byte[]{0, (byte)128, (byte)128};
            case "navy": return new byte[]{0, 0, (byte)128};
            // Add more colors as needed
            default: return null; // Unknown name
        }
    }

    // Constrain integer to byte range 0-255
    private int constrain(int value) {
        return Math.max(0, Math.min(255, value));
    }

     // --- Helper to auto-size columns (Example - adjust as needed) ---
     /*
     private void autoSizeColumns(XSSFSheet sheet) {
         int maxCol = 0;
         for (Row row : sheet) {
             if (row != null && row.getLastCellNum() >= 0) {
                 maxCol = Math.max(maxCol, row.getLastCellNum());
             }
         }
         log.debug("Attempting basic auto-size for {} columns in sheet '{}'", maxCol, sheet.getSheetName());
         for (int i = 0; i < maxCol; i++) {
             try {
                // This can be slow and memory intensive! Use with caution.
                // Consider skipping for very large sheets or setting estimated widths instead.
                 sheet.autoSizeColumn(i);
             } catch (Exception e) {
                 log.warn("Failed to auto-size column {}. Error: {}", i, e.getMessage());
             }
         }
     }
     */

}
```

**主要增强和添加的功能:**

1.  **样式解析重构:** `createStyleFromHtml` 现在通过分号 `;` 分割样式字符串，然后通过冒号 `:` 分割每个声明，以处理多个属性。
2.  **字体处理:**
    * **克隆与缓存:** 在修改字体属性（颜色、大小、名称、粗体、斜体等）之前，会克隆工作簿的默认字体。修改后的字体会基于其属性生成一个 key 并进行缓存 (`htmlFontCache`)，以便重用。使用 `workbook.findFont` 尝试查找工作簿中是否已存在相同字体，以进一步减少重复。
    * **字体大小 (`font-size`):** 添加了 `parseFontSize` 辅助方法来处理 `pt`、`px`（近似转换）和一些常见的关键字（`small`, `medium`, `large` 等）。
    * **字体名称 (`font-family`):** 添加了 `parseFontFamily` 辅助方法，它会尝试从逗号分隔的列表中提取第一个具体的字体名称（去除引号并忽略通用名称如 `serif`）。
3.  **文本换行 (`white-space`):** 如果 CSS 值为 `nowrap`，则设置 `style.setWrapText(false)`；否则（包括 `normal` 或未指定），默认或显式设置为 `true`。
4.  **文本修饰 (`text-decoration`):** 添加了 `parseTextDecoration`，处理 `underline` 和 `line-through`。
5.  **边框处理:**
    * 添加了 `parseGeneralBorder`（用于 `border` 简写属性）和 `parseSpecificBorder`（用于 `border-top` 等）。
    * 添加了 `parseBorderSettings` 辅助方法，尝试从边框值（如 `"1px solid black"`）中提取样式和颜色（宽度解析目前被简化）。
    * 添加了 `mapCssBorderStyle` 将常见的 CSS 边框样式名称（`solid`, `dashed`, `dotted`, `double` 等）映射到 POI 的 `BorderStyle` 枚举。
    * 边框颜色使用现有的 `parseColor` 方法。
6.  **颜色解析 (`parseColor`):** 稍微增强，添加了更多 CSS 颜色名称到 RGB 的映射。添加了一个重载版本 `parseColor(String)`，方便在边框解析等不需要工作簿上下文的地方调用。增加了 `constrain` 方法确保 RGB 值在 0-255 范围内。
7.  **代码结构:** 将样式解析的各个部分分解为更小的辅助方法，提高了可读性。
8.  **健壮性:** 在解析和应用样式时添加了更多的 `try-catch` 块和日志记录。

再次强调，这种从 CSS 到 Excel 样式的转换是**近似的**，并且**仅限于内联样式**。但它现在应该能处理您提到的更多常见样式属性。