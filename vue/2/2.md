您是对的，我之前的代码在字体缓存逻辑中调用 `workbook.findFont` 的方式存在错误。

`XSSFWorkbook.findFont` 方法需要一个 `short` 类型的颜色索引作为参数，但我错误地传递了 `currentFont.getXSSFColor()` 返回的 `XSSFColor` 对象。这两个类型不匹配。

**修正方法:**

直接使用 `XSSFColor` 对象来查找完全匹配的现有字体是很困难且不可靠的，特别是对于通过 RGB 值创建的自定义颜色。最简单且实用的方法是：

1.  **移除 `workbook.findFont` 调用:** 不再尝试让 POI 在工作簿内部查找完全相同的字体。
2.  **依赖字体缓存:** 继续使用我们自己的 `htmlFontCache`。如果一个特定样式字符串解析出了某种字体配置（由 `generateFontKey` 识别），并且这个配置之前已经创建过对应的 `XSSFFont` 对象并放入了缓存，就重用那个缓存的 `XSSFFont` 对象。
3.  **设置字体:** 直接将获取到的（可能是新创建的，也可能是从缓存中取出的）`XSSFFont` 对象设置给 `XSSFCellStyle`。

这可能会导致最终生成的 XLSX 文件内部存在技术上重复的字体定义（如果 POI 没有进行优化），但这通常不会影响文件的正确显示，并且避免了复杂和不可靠的颜色索引映射或手动遍历比较字体的过程。

**以下是修正了 `createAndCacheStyleFromHtml` 方法中字体处理部分的 `ExcelConversionService.java` 代码：**

```java
package com.example.htmltoxlsx.service; // Adjust package name as needed

// ... (Keep all other imports as before) ...
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.DefaultIndexedColorMap;
import org.apache.poi.xssf.usermodel.extensions.XSSFCellBorder.BorderSide;
import org.apache.poi.ss.util.WorkbookUtil;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.awt.Color;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.lang3.StringUtils;

@Service
@Slf4j
public class ExcelConversionService {

    // Caches for performance
    private final Map<String, XSSFCellStyle> htmlStyleCache = new HashMap<>();
    private final Map<String, XSSFFont> htmlFontCache = new HashMap<>();
    private static final int MAX_SUPPORTED_ROWS = 100000;
    private static final int MAX_SUPPORTED_COLS = 200;

    // --- Main Conversion Method: HTML Table String -> XLSX ---
    public byte[] convertOuterHtmlTableToXlsx(MultipartFile file) throws IOException {
        // ... (Method implementation remains the same as the previous correct version) ...
        // ... (Input checks, try-with-resources, HTML parsing, table selection) ...

        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }
        String originalFilename = file.getOriginalFilename();
        log.info("Attempting conversion of HTML table from file ({}) to XLSX format.", originalFilename);
        htmlStyleCache.clear();
        htmlFontCache.clear();

        try (InputStream inputStream = file.getInputStream();
             XSSFWorkbook workbook = new XSSFWorkbook();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            String htmlContent = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
            if (StringUtils.isBlank(htmlContent)) {
                 throw new IllegalArgumentException("Input file contains no processable content.");
            }

            Document doc = Jsoup.parseBodyFragment(htmlContent);
            log.debug("Parsed input stream as HTML body fragment.");

            Element table = doc.body().selectFirst("table");
            if (table == null) {
                throw new IllegalArgumentException("The provided content does not contain a valid HTML table structure.");
            }
            log.debug("Found the first HTML table element to process.");

            String sheetName = "Sheet1";
            XSSFSheet sheet = workbook.createSheet(sheetName);
            log.debug("Processing HTML table into sheet '{}'", sheetName);

            processHtmlTableToSheet(table, sheet, workbook); // Call the processing logic

            workbook.write(baos);
            log.info("Successfully converted HTML table from {} to XLSX format (Sheet: '{}').", originalFilename, sheetName);
            return baos.toByteArray();

        } catch (IOException ioe) {
            log.error("IO Error during HTML to XLSX conversion for file: {}", originalFilename, ioe);
            throw ioe;
        } catch (OutOfMemoryError oom) {
            log.error("OutOfMemoryError during conversion for file: {}. Input HTML might be too large.", originalFilename, oom);
            throw new IOException("Conversion failed due to excessive memory usage. The input HTML may be too large.", oom);
        } catch (Exception e) {
            log.error("Unexpected error during HTML to XLSX conversion for file: {}", originalFilename, e);
            throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e);
        } finally {
            htmlStyleCache.clear();
            htmlFontCache.clear();
        }
    }

    // --- Processes a single HTML table element into an XSSFSheet ---
    private void processHtmlTableToSheet(Element table, XSSFSheet sheet, XSSFWorkbook workbook) {
        // ... (This method implementation remains the same - iterates rows/cells, calls helpers) ...
        Elements rows = table.select("tr");
        int rowIndex = 0;
        boolean[][] cellOccupied = new boolean[Math.min(rows.size(), MAX_SUPPORTED_ROWS) + 5][MAX_SUPPORTED_COLS + 5];
        Map<Integer, Integer> columnMaxChars = new HashMap<>();

        for (Element row : rows) {
             if (rowIndex >= MAX_SUPPORTED_ROWS) break; // Stop if max rows reached
            XSSFRow xssfRow = sheet.createRow(rowIndex);
            Elements cells = row.select("th, td");
            int currentCellIndex = 0;

            for (Element cell : cells) {
                 while (currentCellIndex < MAX_SUPPORTED_COLS && cellOccupied[rowIndex][currentCellIndex]) currentCellIndex++;
                 if (currentCellIndex >= MAX_SUPPORTED_COLS) break; // Stop if max cols reached

                XSSFCell xssfCell = xssfRow.createCell(currentCellIndex);
                String cellText = cell.text();
                setCellValue(xssfCell, cellText);
                updateMaxChars(columnMaxChars, currentCellIndex, cellText);
                XSSFCellStyle xssfStyle = createAndCacheStyleFromHtml(cell, workbook); // Call the corrected style helper
                if (xssfStyle != null) xssfCell.setCellStyle(xssfStyle);
                int colspan = NumberUtils.toInt(cell.attr("colspan"), 1);
                int rowspan = NumberUtils.toInt(cell.attr("rowspan"), 1);
                rowspan = Math.min(rowspan, MAX_SUPPORTED_ROWS - rowIndex);
                colspan = Math.min(colspan, MAX_SUPPORTED_COLS - currentCellIndex);
                handleMergedRegions(sheet, cellOccupied, rowIndex, currentCellIndex, rowspan, colspan);
                currentCellIndex += colspan;
            }
            rowIndex++;
        }
        applyColumnWidths(sheet, columnMaxChars);
    }

    // --- Helper: Create/Cache XSSFCellStyle from HTML inline style attribute ---
    private XSSFCellStyle createAndCacheStyleFromHtml(Element cell, XSSFWorkbook workbook) {
        String styleAttr = cell.attr("style");
        if (StringUtils.isBlank(styleAttr)) {
            return null;
        }

        // --- Style Cache Lookup ---
        if (htmlStyleCache.containsKey(styleAttr)) {
            return htmlStyleCache.get(styleAttr);
        }

        // --- Style and Font Initialization ---
        XSSFCellStyle style = workbook.createCellStyle();
        XSSFFont baseFont = workbook.getFontAt((short) 0);
        XSSFFont currentFont = baseFont;
        boolean fontNeedsCloning = true;
        boolean fontIsModified = false;
        boolean styleIsModified = false;

        style.setWrapText(false); // Start with Excel default (no wrap)

        // --- Parse CSS Declarations ---
        String[] declarations = styleAttr.split(";");
        for (String declaration : declarations) {
            if (StringUtils.isBlank(declaration)) continue;
            String[] parts = declaration.split(":", 2);
            if (parts.length != 2) continue;
            String property = parts[0].trim().toLowerCase();
            String value = parts[1].trim().toLowerCase();

            try {
                // Clone font ONCE if a font-related property is encountered
                if (fontNeedsCloning && isFontProperty(property)) {
                    XSSFFont clonedFont = workbook.createFont();
                    clonedFont.cloneStyleFrom(baseFont);
                    currentFont = clonedFont;
                    fontNeedsCloning = false;
                    fontIsModified = true;
                }

                // Apply relevant styles
                boolean applied = applyCssProperty(property, value, style, currentFont);
                if (applied) {
                    styleIsModified = true;
                    // If a font property was applied, fontIsModified is already true.
                }

            } catch (Exception e) {
                 log.warn("Could not parse/apply style property: '{}' with value '{}'. Error: {}", property, value, e.getMessage());
            }
        }

        // --- Final Font Handling (REVISED) ---
        // If the font object was potentially modified (i.e., currentFont != baseFont),
        // find/cache this specific font configuration and set it on the style.
        if (fontIsModified) {
            String fontKey = generateFontKey(currentFont); // Generate key based on font properties
            // Use computeIfAbsent: If key exists, return cached font; otherwise, create/use currentFont and cache it.
            // No need for workbook.findFont() here. We cache based on properties.
            XSSFFont finalFont = htmlFontCache.computeIfAbsent(fontKey, k -> currentFont);
            style.setFont(finalFont);
            styleIsModified = true; // Font change means style is modified
        }

        // --- Cache and Return ---
        if (styleIsModified) {
            htmlStyleCache.put(styleAttr, style);
            return style;
        } else {
            return null; // No non-default styles applied
        }
    }


    // --- Helper to check if a CSS property affects the font ---
    private boolean isFontProperty(String property) {
         return property.startsWith("font-") || property.equals("color") || property.equals("text-decoration");
    }

    // --- Helper to apply a single CSS property ---
    // (Implementation remains the same - calls specific apply/parse helpers)
    private boolean applyCssProperty(String property, String value, XSSFCellStyle style, XSSFFont font) {
        boolean applied = false;
        switch (property) {
            case "text-align": applied = applyTextAlign(style, value); break;
            case "vertical-align": applied = applyVerticalAlign(style, value); break;
            case "background-color": applied = applyBackgroundColor(style, value); break;
            case "color": applied = applyFontColor(font, value); break;
            case "font-weight": applied = applyFontWeight(font, value); break;
            case "font-style": applied = applyFontStyle(font, value); break;
            case "font-size": applied = parseFontSize(value, font); break;
            case "font-family": applied = parseFontFamily(value, font); break;
            case "text-decoration": applied = parseTextDecoration(value, font); break;
            case "white-space": if ("nowrap".equals(value)) style.setWrapText(false); else style.setWrapText(true); applied = true; break;
            case "border": applied = parseGeneralBorder(value, style); break;
            case "border-top": applied = parseSpecificBorder(value, style, BorderSide.TOP); break;
            case "border-bottom": applied = parseSpecificBorder(value, style, BorderSide.BOTTOM); break;
            case "border-left": applied = parseSpecificBorder(value, style, BorderSide.LEFT); break;
            case "border-right": applied = parseSpecificBorder(value, style, BorderSide.RIGHT); break;
             default: break;
        }
        return applied;
    }

    // --- All other helper methods (updateMaxChars, applyColumnWidths, setCellValue, ---
    // --- handleMergedRegions, applyTextAlign, applyVerticalAlign, applyBackgroundColor, ---
    // --- applyFontColor, applyFontWeight, applyFontStyle, parseFontSize, parseFontFamily, ---
    // --- parseTextDecoration, BorderSettings class, parseGeneralBorder, parseSpecificBorder, ---
    // --- parseBorderSettings, mapCssBorderStyle, parseColor, mapColorNameToRgb, constrain, ---
    // --- generateFontKey) remain IDENTICAL to the previous HTML->XLSX version. ---
    // --- Copy them here from the previous response. ---


    // --- Helper: Update max characters seen for a column ---
    private void updateMaxChars(Map<Integer, Integer> maxCharsMap, int colIndex, String text) {
        int length = (text != null) ? text.length() : 0;
        maxCharsMap.put(colIndex, Math.max(length, maxCharsMap.getOrDefault(colIndex, 0)));
    }

    // --- Helper: Apply estimated column widths ---
    private void applyColumnWidths(XSSFSheet sheet, Map<Integer, Integer> maxCharsMap) {
         final int charWidthFactor = 256;
         final int padding = 2;
         final double defaultCharWidthApproximation = 1.0;
         final int minWidthChars = 8;
         final int maxWidthChars = 100;
         final int excelMaxWidthUnits = 255 * charWidthFactor;

        log.debug("Applying estimated column widths for sheet '{}'", sheet.getSheetName());
        for (Map.Entry<Integer, Integer> entry : maxCharsMap.entrySet()) {
             int colIndex = entry.getKey();
             int maxChars = entry.getValue();
             int clampedMaxChars = Math.min(maxChars, maxWidthChars);
             int width = (int) ((clampedMaxChars + padding) * defaultCharWidthApproximation * charWidthFactor);
             width = Math.max(width, minWidthChars * charWidthFactor);
             width = Math.min(width, excelMaxWidthUnits);
             try {
                 sheet.setColumnWidth(colIndex, width);
             } catch (Exception e) {
                  log.warn("Failed to set width for column {} on sheet '{}'. Error: {}", colIndex, sheet.getSheetName(), e.getMessage());
             }
        }
    }


    // --- Helper: Set cell value with basic type detection ---
    private void setCellValue(XSSFCell cell, String text) {
        if (text == null) { cell.setBlank(); return; }
        String trimmedText = text.trim();
        if ("true".equalsIgnoreCase(trimmedText)) { cell.setCellValue(true); return; }
        if ("false".equalsIgnoreCase(trimmedText)) { cell.setCellValue(false); return; }
        if (NumberUtils.isCreatable(trimmedText)) {
            try { cell.setCellValue(Double.parseDouble(trimmedText)); return;
            } catch (NumberFormatException e) { /* Fallback */ }
        }
        cell.setCellValue(trimmedText);
    }

    // --- Helper: Handle Merged Regions ---
    private void handleMergedRegions(XSSFSheet sheet, boolean[][] occupied, int rIdx, int cIdx, int rowspan, int colspan) {
        if (rowspan > 1 || colspan > 1) {
            if (rIdx >= MAX_SUPPORTED_ROWS || cIdx >= MAX_SUPPORTED_COLS) return;
            int lastRow = Math.min(rIdx + rowspan - 1, MAX_SUPPORTED_ROWS - 1);
            int lastCol = Math.min(cIdx + colspan - 1, MAX_SUPPORTED_COLS - 1);
            if (lastRow < rIdx || lastCol < cIdx) return;
            try {
                CellRangeAddress mergedRegion = new CellRangeAddress(rIdx, lastRow, cIdx, lastCol);
                sheet.addMergedRegion(mergedRegion);
                log.trace("Added merged region: {}", mergedRegion.formatAsString());
                for (int r = rIdx; r <= lastRow; r++) {
                     if (r >= occupied.length) continue;
                    for (int c = cIdx; c <= lastCol; c++) {
                         if (c >= occupied[r].length) continue;
                         if (r > rIdx || c > cIdx) occupied[r][c] = true;
                    }
                }
            } catch (IllegalArgumentException e) {
                 log.warn("Could not add merged region at row {}, col {} ({}x{}). Overlap or invalid range? {}", rIdx, cIdx, rowspan, colspan, e.getMessage());
            } catch (Exception e) { log.error("Error handling merged region at row {}, col {}", rIdx, cIdx, e); }
        }
    }


    // --- Style Application Helpers ---
    private boolean applyTextAlign(XSSFCellStyle style, String value) {
        HorizontalAlignment current = style.getAlignment();
        HorizontalAlignment next = current; // Default to current
        if ("center".equals(value)) next = HorizontalAlignment.CENTER;
        else if ("right".equals(value)) next = HorizontalAlignment.RIGHT;
        else if ("left".equals(value)) next = HorizontalAlignment.LEFT;
        else if ("justify".equals(value)) next = HorizontalAlignment.JUSTIFY;
        if (next != current) { style.setAlignment(next); return true; }
        return false;
    }

    private boolean applyVerticalAlign(XSSFCellStyle style, String value) {
        VerticalAlignment current = style.getVerticalAlignment();
        VerticalAlignment next = current;
        if ("middle".equals(value)) next = VerticalAlignment.CENTER;
        else if ("top".equals(value)) next = VerticalAlignment.TOP;
        else if ("bottom".equals(value)) next = VerticalAlignment.BOTTOM;
        if (next != current) { style.setVerticalAlignment(next); return true; }
        return false;
    }

    private boolean applyBackgroundColor(XSSFCellStyle style, String value) {
        XSSFColor bgColor = parseColor(value);
        if (bgColor != null) {
            // Avoid setting if same as default (e.g. transparent/white)? For now, always set if valid.
            style.setFillForegroundColor(bgColor);
            style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
            return true;
        }
        return false;
    }

    private boolean applyFontColor(XSSFFont font, String value) {
        XSSFColor fontColor = parseColor(value);
        XSSFColor currentColor = font.getXSSFColor(); // POI 5+
        if (fontColor != null && !fontColor.equals(currentColor)) { // Check if color actually changes
            font.setColor(fontColor);
            return true;
        }
        return false;
    }

    private boolean applyFontWeight(XSSFFont font, String value) {
        boolean original = font.getBold();
        boolean next = ("bold".equals(value) || "700".equals(value) || "800".equals(value) || "900".equals(value));
        if (next != original) { font.setBold(next); return true; }
        return false;
    }

     private boolean applyFontStyle(XSSFFont font, String value) {
        boolean original = font.getItalic();
        boolean next = ("italic".equals(value) || "oblique".equals(value));
        if (next != original) { font.setItalic(next); return true; }
        return false;
     }

    // --- Font Size Parsing Helper ---
    private boolean parseFontSize(String value, XSSFFont font) {
        short originalSize = font.getFontHeightInPoints();
        short points = -1;
        try {
            if (value.endsWith("pt")) points = Short.parseShort(value.substring(0, value.length() - 2).trim());
            else if (value.endsWith("px")) points = (short) Math.max(1, Math.round(Integer.parseInt(value.substring(0, value.length() - 2).trim()) * 0.75));
            else if (NumberUtils.isDigits(value)) points = Short.parseShort(value);
            else { // Keywords
                 switch(value) {
                     case "xx-small": points = 6; break; case "x-small": points = 7; break; case "small": points = 8; break;
                     case "medium": points = 10; break; case "large": points = 12; break; case "x-large": points = 14; break;
                     case "xx-large": points = 18; break;
                 }
            }
            if (points > 0 && points != originalSize) { font.setFontHeightInPoints(points); return true; }
        } catch (Exception e) { log.warn("Could not parse font-size: '{}'. Error: {}", value, e.getMessage()); }
        return false;
    }

    // --- Font Family Parsing Helper ---
    private boolean parseFontFamily(String value, XSSFFont font) {
        String originalName = font.getFontName();
        String finalName = originalName;
        try {
            String[] families = value.split(",");
            if (families.length > 0) {
                String firstFamily = StringUtils.strip(families[0].trim(), "'\"");
                if (!"serif".equalsIgnoreCase(firstFamily) && !"sans-serif".equalsIgnoreCase(firstFamily) && !"monospace".equalsIgnoreCase(firstFamily)
                   && !"cursive".equalsIgnoreCase(firstFamily) && !"fantasy".equalsIgnoreCase(firstFamily) && StringUtils.isNotBlank(firstFamily))
                {
                     finalName = firstFamily;
                }
            }
        } catch (Exception e) { log.warn("Could not parse font-family: '{}'. Error: {}", value, e.getMessage()); return false; }
        if (!StringUtils.equals(finalName, originalName)) { font.setFontName(finalName); return true; }
        return false;
    }

    // --- Text Decoration Parsing Helper ---
     private boolean parseTextDecoration(String value, XSSFFont font) {
         boolean changed = false;
         byte currentUnderline = font.getUnderline();
         boolean currentStrike = font.getStrikeout();
         byte nextUnderline = Font.U_NONE;
         boolean nextStrike = false;

         if (value.contains("underline")) nextUnderline = Font.U_SINGLE;
         if (value.contains("line-through")) nextStrike = true;

         if (nextUnderline != currentUnderline) { font.setUnderline(nextUnderline); changed = true; }
         if (nextStrike != currentStrike) { font.setStrikeout(nextStrike); changed = true; }
         return changed;
     }

    // --- Border Parsing Helpers ---
    private static class BorderSettings {
        BorderStyle style = BorderStyle.NONE;
        XSSFColor color = null;
    }

    private boolean parseGeneralBorder(String value, XSSFCellStyle style) {
        BorderSettings settings = parseBorderSettings(value);
        if (settings != null) {
            style.setBorderTop(settings.style); style.setTopBorderColor(settings.color);
            style.setBorderBottom(settings.style); style.setBottomBorderColor(settings.color);
            style.setBorderLeft(settings.style); style.setLeftBorderColor(settings.color);
            style.setBorderRight(settings.style); style.setRightBorderColor(settings.color);
            return true;
        } else { // Explicitly set to none if value is 'none' or unparseable maybe? Or assume no change? Assume no change.
            return false;
        }
    }

    private boolean parseSpecificBorder(String value, XSSFCellStyle style, BorderSide side) {
         BorderSettings settings = parseBorderSettings(value);
         BorderStyle styleToSet = BorderStyle.NONE;
         XSSFColor colorToSet = null;
         if(settings != null) {
             styleToSet = settings.style;
             colorToSet = settings.color;
         }
         // TODO: Check if style/color actually changes before applying?
         switch(side) {
             case TOP: style.setBorderTop(styleToSet); style.setTopBorderColor(colorToSet); break;
             case BOTTOM: style.setBorderBottom(styleToSet); style.setBottomBorderColor(colorToSet); break;
             case LEFT: style.setBorderLeft(styleToSet); style.setLeftBorderColor(colorToSet); break;
             case RIGHT: style.setBorderRight(styleToSet); style.setRightBorderColor(colorToSet); break;
         }
         return settings != null; // Return true if we parsed and applied something (even if it was 'none')
    }

    private BorderSettings parseBorderSettings(String value) {
        if (StringUtils.isBlank(value) || "none".equals(value.trim())) return new BorderSettings(); // Return settings for NONE
        BorderSettings settings = new BorderSettings();
        settings.style = BorderStyle.NONE; // Default to none unless specified
        String[] parts = value.split("\\s+");

        for (String part : parts) {
            if (StringUtils.isBlank(part)) continue;
            if (settings.color == null) {
                 XSSFColor parsedColor = parseColor(part);
                 if (parsedColor != null) { settings.color = parsedColor; continue; }
            }
            BorderStyle parsedStyle = mapCssBorderStyle(part);
            if (parsedStyle != BorderStyle.NONE) { settings.style = parsedStyle; continue; }
            // Could parse width here -> map to THIN/MEDIUM/THICK style?
        }
        // Default color to black if style was set but no color found
        if (settings.style != BorderStyle.NONE && settings.color == null) {
            settings.color = new XSSFColor(IndexedColors.BLACK.getIndexed(), new DefaultIndexedColorMap());
        }
        // If only color specified, default border style to THIN? Common use case.
        if (settings.style == BorderStyle.NONE && settings.color != null) {
             settings.style = BorderStyle.THIN;
        }
        return settings;
    }

    private BorderStyle mapCssBorderStyle(String cssStyle) {
         switch (cssStyle) {
             case "solid": return BorderStyle.THIN; case "dashed": return BorderStyle.DASHED;
             case "dotted": return BorderStyle.DOTTED; case "double": return BorderStyle.DOUBLE;
             case "groove": return BorderStyle.GROOVE; case "ridge": return BorderStyle.RIDGE;
             case "inset": return BorderStyle.INSET; case "outset": return BorderStyle.OUTSET;
             case "thin": return BorderStyle.THIN; case "medium": return BorderStyle.MEDIUM;
             case "thick": return BorderStyle.THICK;
             case "hidden": case "none": default: return BorderStyle.NONE;
         }
    }

    // --- Color Parsing Helper ---
    private XSSFColor parseColor(String colorStr) {
         if (StringUtils.isBlank(colorStr)) return null;
         colorStr = colorStr.toLowerCase().trim();
         byte[] rgb = null;
         IndexedColorMap colorMap = new DefaultIndexedColorMap();

        try {
            if (colorStr.startsWith("#")) {
                String hex = colorStr.substring(1);
                if (hex.length() == 3) hex = "" + hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
                if (hex.length() == 6) {
                     rgb = new byte[]{ (byte)Integer.parseInt(hex.substring(0, 2), 16), (byte)Integer.parseInt(hex.substring(2, 4), 16), (byte)Integer.parseInt(hex.substring(4, 6), 16) };
                }
            } else if (colorStr.startsWith("rgb(")) {
                 String[] parts = colorStr.substring(4, colorStr.length() - 1).split(",");
                 if (parts.length == 3) { rgb = new byte[]{ (byte) constrain(Integer.parseInt(parts[0].trim())), (byte) constrain(Integer.parseInt(parts[1].trim())), (byte) constrain(Integer.parseInt(parts[2].trim())) }; }
            } else { rgb = mapColorNameToRgb(colorStr); }
        } catch (Exception e) { log.warn("Could not parse color string: '{}'. Error: {}", colorStr, e.getMessage()); return null; }

        if (rgb != null) {
             try { return new XSSFColor(rgb, colorMap); }
             catch (Exception e) { log.warn("Failed to create XSSFColor from RGB for '{}'. Error: {}", colorStr, e.getMessage()); return null; }
        }
        return null;
    }

    // Map common CSS color names to RGB byte arrays
    private byte[] mapColorNameToRgb(String name) {
        switch (name) {
            case "black": return new byte[]{0, 0, 0}; case "white": return new byte[]{(byte)255, (byte)255, (byte)255};
            case "red": return new byte[]{(byte)255, 0, 0}; case "lime": return new byte[]{0, (byte)255, 0};
            case "green": return new byte[]{0, (byte)128, 0}; case "blue": return new byte[]{0, 0, (byte)255};
            case "yellow": return new byte[]{(byte)255, (byte)255, 0}; case "cyan": case "aqua": return new byte[]{0, (byte)255, (byte)255};
            case "magenta": case "fuchsia": return new byte[]{(byte)255, 0, (byte)255}; case "silver": return new byte[]{(byte)192, (byte)192, (byte)192};
            case "gray": case "grey": return new byte[]{(byte)128, (byte)128, (byte)128}; case "maroon": return new byte[]{(byte)128, 0, 0};
            case "olive": return new byte[]{(byte)128, (byte)128, 0}; case "purple": return new byte[]{(byte)128, 0, (byte)128};
            case "teal": return new byte[]{0, (byte)128, (byte)128}; case "navy": return new byte[]{0, 0, (byte)128};
            // Add transparent? Excel handles this via no-fill or pattern usually.
            case "transparent": return null; // Treat transparent as no color / no fill
            default: return null;
        }
    }

    // Constrain integer to byte range 0-255
    private int constrain(int value) { return Math.max(0, Math.min(255, value)); }

    // --- Helper to generate a unique key for font caching ---
    private String generateFontKey(XSSFFont font) {
        XSSFColor color = font.getXSSFColor();
        String colorHex = "auto"; // Default if color is null or complex (e.g., themed, tinted)
        if (color != null && color.isRGB() && color.hasTint() == 0.0) {
             try {
                 colorHex = color.getARGBHex(); // Use ARGB Hex for RGB colors without tint
             } catch (Exception e) { /* fallback to 'auto' if getARGBHex fails */ }
        }

        return String.format("%s|%d|%s|%b|%b|%b|%d|%d",
                font.getFontName(), font.getFontHeightInPoints(), colorHex,
                font.getBold(), font.getItalic(), font.getStrikeout(),
                font.getUnderline(), font.getTypeOffset()
        );
    }

}
```

**关键变化总结:**

1.  **输入处理:** 代码现在读取 `MultipartFile` 的内容为字符串，并使用 `Jsoup.parseBodyFragment` 解析，这适用于只包含 `<table>` 及其内容的文本文件。
2.  **表格选择:** 使用 `doc.body().selectFirst("table")` 来确保只处理在文件片段中找到的第一个（通常是最外层的）表格。
3.  **单 Sheet 输出:** 移除了处理多个表格的循环，固定将结果输出到名为 "Sheet1" 的工作表中。
4.  **核心逻辑不变:** 数据提取、样式解析、合并单元格处理和列宽估算等核心辅助方法与之前的 HTML->XLSX 版本保持一致。
5.  **健壮性:** 添加了对行数和列数的限制，并在相关操作中增加了边界检查。

这个版本应该能更好地处理您描述的特定输入场景（只包含表格内容的文本文件），同时继续提供尽可能好的样式保留（在 HTML 内联样式的限制下）。