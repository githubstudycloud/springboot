Okay, the error message "Invalid header signature; read 0x73... expected 0xE... - Your file appears not to be a valid OLE2 document" is **very important**.

* **OLE2:** This is the underlying binary format for older Microsoft Office files like `.xls` (Excel 97-2003). It has a specific sequence of bytes at the beginning (the "header signature") that identifies it.
* **The Error:** Apache POI's `HSSFWorkbook` is designed *exclusively* to read these binary OLE2 `.xls` files. When it tried to read your uploaded file, it did *not* find the expected OLE2 signature. Instead, it read bytes starting with `0x73` (which is the ASCII code for the letter 's').
* **Vue 2.7 Export:** Client-side JavaScript libraries used in Vue (like SheetJS/`xlsx`, `exceljs`, or even simple table-to-Excel plugins) **almost never generate true, binary OLE2 `.xls` files.** It's a very complex format to create in a browser.
    * **Most Likely Scenario:** Your Vue application is probably generating an **HTML table** and saving it with an `.xls` extension. Modern Excel versions are often smart enough to open these HTML files and display them like spreadsheets, but **they are fundamentally HTML files, not binary XLS files.** The `0x73` byte POI read could easily be part of an HTML tag like `<st...` or `<sc...`.

**Conclusion:** Apache POI's `HSSFWorkbook` cannot read the file your Vue app is sending because it's not a real XLS file. The previous code, designed for true XLS conversion, will not work.

**Solution: Adapt to the Actual File Format (Likely HTML)**

We need to change the backend code to parse the *actual* content of the file, which we strongly suspect is HTML. We can use a Java HTML parsing library like **Jsoup** to read the HTML table data and then use Apache POI's **XSSFWorkbook** (for `.xlsx` output) to create a proper Excel file from that data.

**Important Considerations:**

1.  **Data Extraction:** We can reliably extract the text content from the HTML table cells.
2.  **Style Preservation:** Replicating styles from HTML+CSS to Excel's styling model is **difficult and often incomplete**. We can attempt to copy *basic* inline styles (like `background-color`, `color`, `font-weight`), but complex CSS rules, classes, or inherited styles will likely be lost. The result will primarily focus on getting the data structure correct in the `.xlsx` file.
3.  **Merged Cells:** We can handle basic `colspan` and `rowspan` attributes from the HTML table to create merged regions in the output XLSX.

**Steps:**

1.  **Add Jsoup Dependency:** Add this to your `pom.xml`:
    ```xml
    <dependency>
        <groupId>org.jsoup</groupId>
        <artifactId>jsoup</artifactId>
        <version>1.17.2</version> </dependency>
    ```
2.  **Modify `ExcelConversionService.java`:** Replace the entire `convertXlsToXlsx` method and its helpers with logic that uses Jsoup to parse HTML and POI XSSF to build the XLSX.

**Revised `ExcelConversionService.java` (Assuming HTML Input):**

```java
package com.example.xlstoxlsxconverter.service;

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI (XSSF for .xlsx output) imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFColor; // Correct import for XSSFColor

// Jsoup (HTML Parsing) imports
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.math.NumberUtils; // For robust number parsing
import org.apache.commons.lang3.StringUtils; // For string utilities

@Service
@Slf4j
public class ExcelConversionService {

    // Cache for basic styles derived from HTML (optional, can improve performance)
    private final Map<String, XSSFCellStyle> htmlStyleCache = new HashMap<>();
    // Pattern to extract simple inline style properties
    private static final Pattern STYLE_PROPERTY_PATTERN = Pattern.compile("([^:]+):\\s*([^;]+);?");

    public byte[] convertHtmlTableToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }

        String originalFilename = file.getOriginalFilename();
        log.info("Received file suspected to be HTML table masquerading as XLS: {}", originalFilename);

        // Clear cache for this conversion
        htmlStyleCache.clear();

        try (InputStream inputStream = file.getInputStream();
             XSSFWorkbook xssfWorkbook = new XSSFWorkbook(); // Create target XLSX
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            // --- Jsoup HTML Parsing ---
            // Assuming UTF-8 encoding, adjust if needed. Base URI is usually not critical here.
            Document doc = Jsoup.parse(inputStream, "UTF-8", "");
            log.debug("Successfully parsed input stream as HTML using Jsoup.");

            // Find the first table (adjust selector if needed, e.g., "table#myTableId", "table.myExportClass")
            Element table = doc.selectFirst("table");
            if (table == null) {
                log.error("No <table> element found in the uploaded file: {}", originalFilename);
                throw new IllegalArgumentException("The uploaded file does not contain an HTML table.");
            }
            log.debug("Found HTML table element.");

            XSSFSheet xssfSheet = xssfWorkbook.createSheet("Sheet1"); // Create sheet in XLSX

            // --- Data and Basic Style Extraction ---
            Elements rows = table.select("tr"); // Get all table rows
            int rowIndex = 0;
            // Keep track of merged cells to avoid writing over them
            boolean[][] cellOccupied = new boolean[rows.size() + 50][200]; // Estimate max rows/cols, adjust size dynamically if needed

            log.info("Processing {} rows from HTML table...", rows.size());
            for (Element row : rows) {
                XSSFRow xssfRow = xssfSheet.createRow(rowIndex);
                Elements cells = row.select("th, td"); // Get cells (header or data)

                int currentCellIndex = 0;
                for (Element cell : cells) {
                    // Skip columns already occupied by a rowspan from a previous row
                    while (currentCellIndex < cellOccupied[rowIndex].length && cellOccupied[rowIndex][currentCellIndex]) {
                        currentCellIndex++;
                    }

                    // --- Cell Value ---
                    String cellText = cell.text(); // Get text content
                    XSSFCell xssfCell = xssfRow.createCell(currentCellIndex);
                    setCellValue(xssfCell, cellText); // Set value (attempts number conversion)

                    // --- Basic Style Approximation ---
                    XSSFCellStyle xssfStyle = createStyleFromHtml(cell, xssfWorkbook);
                    if (xssfStyle != null) {
                         xssfCell.setCellStyle(xssfStyle);
                    }

                    // --- Handle Colspan and Rowspan for Merged Regions ---
                    int colspan = NumberUtils.toInt(cell.attr("colspan"), 1);
                    int rowspan = NumberUtils.toInt(cell.attr("rowspan"), 1);

                    if (colspan > 1 || rowspan > 1) {
                        try {
                            CellRangeAddress mergedRegion = new CellRangeAddress(
                                    rowIndex, // first row
                                    rowIndex + rowspan - 1, // last row
                                    currentCellIndex, // first col
                                    currentCellIndex + colspan - 1 // last col
                            );
                            xssfSheet.addMergedRegion(mergedRegion);
                            log.trace("Added merged region: {}", mergedRegion.formatAsString());

                            // Mark cells covered by rowspan/colspan as occupied for subsequent rows/cells
                            for (int r = rowIndex; r < rowIndex + rowspan; r++) {
                                for (int c = currentCellIndex; c < currentCellIndex + colspan; c++) {
                                     if (r >= cellOccupied.length || c >= cellOccupied[r].length) {
                                        // Resize array if needed - more robust implementation recommended
                                        log.warn("Cell occupancy array size exceeded at [{}, {}]. Merged cell tracking might be incomplete.", r, c);
                                        continue; // Skip marking if out of bounds
                                     }
                                    if (r > rowIndex || c > currentCellIndex) { // Don't mark the top-left cell itself initially
                                        cellOccupied[r][c] = true;
                                    }
                                }
                            }
                        } catch (IllegalArgumentException e) {
                             log.warn("Could not add merged region at row {}, col {} (colspan={}, rowspan={}). Overlap possible? {}",
                                     rowIndex, currentCellIndex, colspan, rowspan, e.getMessage());
                        }
                    }
                    // Move to the next available cell index, considering colspan
                    currentCellIndex += colspan;
                }
                rowIndex++;
            }
            log.info("Finished processing HTML table rows.");

            // --- Auto-size columns (optional, can be slow for large sheets) ---
             // Adjust based on estimated content, as full auto-sizing needs rendering context
             // Basic heuristic: loop through unique columns used and set a reasonable width
             // int maxCol = // ... determine max column index used ...
             // for (int i = 0; i < maxCol; i++) {
             //     xssfSheet.autoSizeColumn(i); // Or set a fixed width based on content length estimate
             // }


            // Write the XLSX workbook to the output stream
            xssfWorkbook.write(baos);
            log.info("Successfully converted HTML table from {} to XLSX format.", originalFilename);
            return baos.toByteArray();

        } catch (IOException ioe) {
            log.error("IO Error during HTML table to XLSX conversion for file: {}", originalFilename, ioe);
            throw ioe;
        } catch (Exception e) {
            log.error("Unexpected error during HTML table to XLSX conversion for file: {}", originalFilename, e);
            throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e);
        } finally {
            htmlStyleCache.clear();
        }
    }

    // --- Helper to set cell value (with basic type detection) ---
    private void setCellValue(XSSFCell cell, String text) {
        if (text == null) {
            cell.setBlank();
            return;
        }
        // Try parsing as a number
        if (NumberUtils.isCreatable(text)) {
            try {
                cell.setCellValue(Double.parseDouble(text));
                return;
            } catch (NumberFormatException e) {
                // Fallback to string if parsing fails despite isCreatable being true
            }
        }
        // Check for boolean
        if ("true".equalsIgnoreCase(text)) {
            cell.setCellValue(true);
        } else if ("false".equalsIgnoreCase(text)) {
            cell.setCellValue(false);
        } else {
            // Default to string
            cell.setCellValue(text.trim()); // Trim whitespace
        }
    }


    // --- Helper to create basic XSSFCellStyle from HTML element's inline style ---
    private XSSFCellStyle createStyleFromHtml(Element cell, XSSFWorkbook workbook) {
        String styleAttr = cell.attr("style");
        if (StringUtils.isBlank(styleAttr)) {
            return null; // No inline style
        }

        // Use cache key based on the style string
        if (htmlStyleCache.containsKey(styleAttr)) {
            return htmlStyleCache.get(styleAttr);
        }

        XSSFCellStyle style = workbook.createCellStyle();
        XSSFFont font = workbook.createFont(); // Assume default font unless style dictates otherwise
        boolean fontModified = false;

        Matcher matcher = STYLE_PROPERTY_PATTERN.matcher(styleAttr);
        while (matcher.find()) {
            String property = matcher.group(1).trim().toLowerCase();
            String value = matcher.group(2).trim().toLowerCase();

            try {
                switch (property) {
                    case "background-color":
                        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
                        style.setFillForegroundColor(parseColor(value, workbook));
                        break;
                    case "color": // Font color
                        font.setColor(parseColor(value, workbook));
                        fontModified = true;
                        break;
                    case "font-weight":
                        if ("bold".equals(value) || NumberUtils.toInt(value, 400) >= 700) {
                            font.setBold(true);
                            fontModified = true;
                        }
                        break;
                    case "font-style":
                        if ("italic".equals(value) || "oblique".equals(value)) {
                            font.setItalic(true);
                            fontModified = true;
                        }
                        break;
                    case "text-align":
                        switch (value) {
                            case "left":    style.setAlignment(HorizontalAlignment.LEFT);   break;
                            case "center":  style.setAlignment(HorizontalAlignment.CENTER); break;
                            case "right":   style.setAlignment(HorizontalAlignment.RIGHT);  break;
                            case "justify": style.setAlignment(HorizontalAlignment.JUSTIFY); break;
                        }
                        break;
                    case "vertical-align":
                         switch (value) {
                             case "top":     style.setVerticalAlignment(VerticalAlignment.TOP);    break;
                             case "middle":  style.setVerticalAlignment(VerticalAlignment.CENTER); break;
                             case "bottom":  style.setVerticalAlignment(VerticalAlignment.BOTTOM); break;
                         }
                         break;
                    // Add more cases for other simple styles if needed (e.g., text-decoration for underline)
                    case "text-decoration":
                         if (value.contains("underline")) {
                             font.setUnderline(Font.U_SINGLE);
                             fontModified = true;
                         }
                         if (value.contains("line-through")) {
                            font.setStrikeout(true);
                            fontModified = true;
                         }
                         break;
                }
            } catch (Exception e) {
                log.warn("Could not parse style property '{}' with value '{}'. Error: {}", property, value, e.getMessage());
            }
        }

        if (fontModified) {
            style.setFont(font);
        }

        // Cache the created style only if it has properties beyond default
        if (style.getFillPattern() != FillPatternType.NO_FILL || style.getAlignment() != HorizontalAlignment.GENERAL || fontModified) {
             htmlStyleCache.put(styleAttr, style);
        } else {
            return null; // Return null if style is essentially default
        }


        return style;
    }

    // --- Helper to parse CSS color strings (hex, rgb, names) into XSSFColor ---
    private XSSFColor parseColor(String colorStr, XSSFWorkbook workbook) {
         if (StringUtils.isBlank(colorStr)) return null;
         colorStr = colorStr.toLowerCase().trim();

         byte[] rgb = null;

        try {
            if (colorStr.startsWith("#")) {
                // Hex color (#RRGGBB or #RGB)
                String hex = colorStr.substring(1);
                if (hex.length() == 3) { // Expand #RGB to #RRGGBB
                    hex = "" + hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
                }
                if (hex.length() == 6) {
                     int r = Integer.parseInt(hex.substring(0, 2), 16);
                     int g = Integer.parseInt(hex.substring(2, 4), 16);
                     int b = Integer.parseInt(hex.substring(4, 6), 16);
                     rgb = new byte[]{(byte) r, (byte) g, (byte) b};
                }
            } else if (colorStr.startsWith("rgb(")) {
                // rgb(r, g, b)
                 String[] parts = colorStr.substring(4, colorStr.length() - 1).split(",");
                 if (parts.length == 3) {
                     int r = Integer.parseInt(parts[0].trim());
                     int g = Integer.parseInt(parts[1].trim());
                     int b = Integer.parseInt(parts[2].trim());
                     rgb = new byte[]{(byte) r, (byte) g, (byte) b};
                 }
            } else {
                // Try basic color names (add more if needed)
                switch (colorStr) {
                    case "black":   rgb = new byte[]{0, 0, 0}; break;
                    case "white":   rgb = new byte[]{(byte)255, (byte)255, (byte)255}; break;
                    case "red":     rgb = new byte[]{(byte)255, 0, 0}; break;
                    case "green":   rgb = new byte[]{0, (byte)128, 0}; break; // Excel Green is often 0,128,0
                    case "blue":    rgb = new byte[]{0, 0, (byte)255}; break;
                    case "yellow":  rgb = new byte[]{(byte)255, (byte)255, 0}; break;
                    case "gray":
                    case "grey":    rgb = new byte[]{(byte)128, (byte)128, (byte)128}; break;
                    // Map to IndexedColors maybe? Or just use RGB.
                }
            }
        } catch (NumberFormatException | IndexOutOfBoundsException e) {
             log.warn("Could not parse color string: '{}'. Error: {}", colorStr, e.getMessage());
             return null;
        }

        if (rgb != null) {
             // Use default IndexedColorMap for potential mapping? Or null is fine for custom RGB.
             return new XSSFColor(rgb, null);
        }
        return null; // Return null if color couldn't be parsed
    }
}
```

**Key Changes:**

1.  **Core Logic:** The service now uses Jsoup to parse the input file as HTML.
2.  **No `HSSFWorkbook`:** All references to `HSSFWorkbook` and related HSSF classes are removed from the primary conversion path.
3.  **HTML Table Parsing:** It selects the first `<table>` and iterates through its `<tr>` and `<td>`/`<th>` elements.
4.  **`XSSFWorkbook` Output:** It directly builds an `XSSFWorkbook` to create a standard `.xlsx` file.
5.  **Value Extraction:** Uses `element.text()` to get cell content and includes basic logic (`setCellValue` helper) to try and detect numbers or booleans.
6.  **Basic Style Parsing:**
    * The `createStyleFromHtml` helper attempts to read inline `style="..."` attributes on `<td>`/`<th>` elements.
    * It parses simple CSS properties like `background-color`, `color`, `font-weight`, `font-style`, `text-align`.
    * The `parseColor` helper handles basic CSS color formats (#RRGGBB, #RGB, rgb(r,g,b), and a few common names) and converts them to `XSSFColor`.
    * **Limitation:** This styling is very basic and will miss styles applied via CSS classes, stylesheets, or inherited styles.
7.  **Merged Cells:** Handles `colspan` and `rowspan` attributes to create merged regions using `CellRangeAddress`. Includes basic tracking to avoid writing data into cells covered by a rowspan from a previous row.
8.  **Dependencies:** Requires `org.jsoup:jsoup` and `org.apache.commons:commons-lang3` (for `NumberUtils`, `StringUtils`) to be added to your `pom.xml`.

**How to Use:**

1.  Update your `pom.xml` with Jsoup and Commons Lang3.
2.  Replace the old `ExcelConversionService.java` with this new version.
3.  Your controller (`ExcelConversionController`) likely doesn't need changes, as it just passes the `MultipartFile` to the service and handles the byte array response. It might be good practice to rename the service method called by the controller to reflect that it now expects HTML, e.g., call `convertHtmlTableToXlsx` instead of `convertXlsToXlsx`.

This approach directly addresses the "Invalid header signature" error by correctly interpreting the likely HTML input and transforming it into a proper XLSX file using POI's XSSF components. Remember that the visual fidelity compared to the original browser render will be limited due to the complexities of CSS-to-Excel style mapping.