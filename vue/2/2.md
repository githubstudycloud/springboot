Okay, you are absolutely right to point out these issues. Let's fix them specifically:

1.  **Line ~406 (`getOrCreateXSSFFont`):** `hssfFont.getIndexAsInt()` indeed returns an `int`. Storing it in a `short` requires an explicit cast or changing the variable type. Since the `fontMap` key is `Short`, we'll use an `int` for the variable and cast it when using the map key.
2.  **Line ~550 (`copyHyperlink`):** The types *should* match (`setCellReference` expects String, `formatAsString` returns String). The error might be misleading or stem from an import issue. Let's ensure imports are correct and add a null check for robustness.
3.  **Line ~614 (`copyHyperlink`):** `HSSFHyperlink.getTypeEnum()` does not exist in recent POI versions. The correct method is `HSSFHyperlink.getType()`, which directly returns the `HyperlinkType` enum (from `org.apache.poi.common.usermodel.HyperlinkType`).

Here is the rewritten `ExcelConversionService.java` with these specific corrections applied:

```java
package com.example.xlstoxlsxconverter.service;

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI Base (Shared) imports
import org.apache.poi.common.usermodel.HyperlinkType; // Correct HyperlinkType enum
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress; // Ensure this import is correct
import org.apache.poi.util.RecordFormatException;
import org.apache.poi.ss.formula.FormulaParseException;

// Apache POI HSSF (.xls) specific imports
import org.apache.poi.hssf.usermodel.*;
import org.apache.poi.hssf.util.HSSFColor;

// Apache POI XSSF (.xlsx) specific imports
import org.apache.poi.xssf.usermodel.*; // Ensure XSSFHyperlink is imported correctly if needed directly (usually via CreationHelper)

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class ExcelConversionService {

    private final Map<Integer, XSSFCellStyle> styleMap = new HashMap<>();
    // Keep map key as Short assuming indices fit, but use int locally for font index
    private final Map<Short, XSSFFont> fontMap = new HashMap<>();
    private XSSFCellStyle defaultHyperlinkStyle = null;


    public byte[] convertXlsToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }

        String originalFilename = file.getOriginalFilename();
        log.info("Received request to convert file: {}", originalFilename);
        if (originalFilename == null || !originalFilename.toLowerCase().endsWith(".xls")) {
             log.warn("Input file might not be an XLS file (based on extension): {}", originalFilename);
        }

        // Clear caches
        styleMap.clear();
        fontMap.clear();
        defaultHyperlinkStyle = null;


        try (InputStream inputStream = file.getInputStream();
             HSSFWorkbook hssfWorkbook = new HSSFWorkbook(inputStream);
             XSSFWorkbook xssfWorkbook = new XSSFWorkbook();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            log.info("Starting XLS to XLSX conversion process for: {}", originalFilename);

            int numberOfSheets = hssfWorkbook.getNumberOfSheets();
            log.debug("Source workbook contains {} sheets.", numberOfSheets);
            HSSFPalette hssfPalette = hssfWorkbook.getCustomPalette();

            for (int i = 0; i < numberOfSheets; i++) {
                HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(i);
                XSSFSheet xssfSheet = xssfWorkbook.createSheet(hssfSheet.getSheetName());
                log.debug("Processing sheet: '{}' (Index {})", hssfSheet.getSheetName(), i);

                copyMergedRegions(hssfSheet, xssfSheet);
                copyRowsAndCells(hssfSheet, xssfSheet, hssfWorkbook, xssfWorkbook, hssfPalette);
                copyColumnWidths(hssfSheet, xssfSheet);
                // Optional: copy other sheet settings
            }

            xssfWorkbook.write(baos);
            log.info("Successfully converted file: {}", originalFilename);
            return baos.toByteArray();

        } catch (IOException ioe) {
            log.error("IO Error during conversion for file: {}", originalFilename, ioe);
            throw ioe;
        } catch (RecordFormatException | FormulaParseException rfe) {
             log.error("Error processing file format or formula in {}. File might be corrupted or contain unsupported features.", originalFilename, rfe);
             throw new IOException("Conversion failed due to format/formula issue: " + rfe.getMessage(), rfe);
        }
        catch (Exception e) {
            log.error("Unexpected error during conversion for file: {}", originalFilename, e);
            throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e);
        } finally {
             styleMap.clear();
             fontMap.clear();
             defaultHyperlinkStyle = null;
             log.debug("Cleared conversion caches.");
        }
    }

    // --- Core Row and Cell Copying Logic ---
    private void copyRowsAndCells(HSSFSheet hssfSheet, XSSFSheet xssfSheet, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook, HSSFPalette hssfPalette) {
        int maxColNum = 0;

        for (int rowIndex = hssfSheet.getFirstRowNum(); rowIndex <= hssfSheet.getLastRowNum(); rowIndex++) {
            HSSFRow hssfRow = hssfSheet.getRow(rowIndex);
            if (hssfRow == null) continue;

            XSSFRow xssfRow = xssfSheet.createRow(rowIndex);
            copyRowProperties(hssfRow, xssfRow);

            for (int colIndex = hssfRow.getFirstCellNum(); colIndex >= 0 && colIndex < hssfRow.getLastCellNum(); colIndex++) {
                 HSSFCell hssfCell = hssfRow.getCell(colIndex);
                 if (hssfCell == null) continue;

                 XSSFCell xssfCell = xssfRow.createCell(colIndex); // Create cell first

                 // Copy Style FIRST - needed for date formatting check in value copy
                 HSSFCellStyle hssfStyle = hssfCell.getCellStyle();
                 if (hssfStyle != null) {
                      XSSFCellStyle xssfStyle = getOrCreateXSSFStyle(hssfStyle, hssfWorkbook, xssfWorkbook, hssfPalette);
                      if (xssfStyle != null) {
                         xssfCell.setCellStyle(xssfStyle);
                      }
                 }

                 // Copy Cell Value (Handles Formulas, uses style for date check)
                 copyCellValue(hssfCell, xssfCell); // Pass target cell which now has style

                 // Copy Cell Comment
                 HSSFComment hssfComment = hssfCell.getCellComment();
                 if (hssfComment != null) {
                      copyCellComment(hssfComment, xssfCell);
                 }

                 // Copy Hyperlink
                 HSSFHyperlink hssfLink = hssfCell.getHyperlink();
                 if (hssfLink != null) {
                     copyHyperlink(hssfLink, xssfCell);
                 }

                 maxColNum = Math.max(maxColNum, colIndex + 1);
            }
        }
        log.debug("Finished copying rows/cells for sheet '{}'. Max columns used: {}", xssfSheet.getSheetName(), maxColNum);
    }

    // --- Copy Row Properties ---
    private void copyRowProperties(HSSFRow hssfRow, XSSFRow xssfRow) {
        xssfRow.setHeightInPoints(hssfRow.getHeightInPoints());
        if (hssfRow.getZeroHeight()) {
            xssfRow.setZeroHeight(true);
        }
        // Copy row style if needed
    }


    // --- Cell Value Copying ---
    private void copyCellValue(HSSFCell hssfCell, XSSFCell xssfCell) {
        CellType cellType = hssfCell.getCellType();

        if (cellType == CellType.FORMULA) {
            String formula = hssfCell.getCellFormula();
            try {
                xssfCell.setCellFormula(formula);
            } catch (FormulaParseException | RecordFormatException fpe) {
                log.warn("Could not copy formula '{}' from HSSF[{},{}] to XSSF. Attempting to copy cached value. Error: {}",
                         formula, hssfCell.getRowIndex(), hssfCell.getColumnIndex(), fpe.getMessage());
                copyCachedFormulaValue(hssfCell, xssfCell);
            } catch (Exception e) {
                log.error("Unexpected error setting formula '{}' at XSSF[{},{}].",
                          formula, xssfCell.getRowIndex(), xssfCell.getColumnIndex(), e);
                xssfCell.setBlank();
            }
        } else {
            switch (cellType) {
                case STRING:
                    xssfCell.setCellValue(hssfCell.getStringCellValue());
                    break;
                case NUMERIC:
                    // Pass the target cell to check its style for date format hint
                    copyNumericCellValue(hssfCell, xssfCell);
                    break;
                case BOOLEAN:
                    xssfCell.setCellValue(hssfCell.getBooleanCellValue());
                    break;
                case BLANK:
                    xssfCell.setBlank();
                    break;
                case ERROR:
                    xssfCell.setCellErrorValue(hssfCell.getErrorCellValue());
                    break;
                default:
                    log.warn("Unhandled HSSF cell type '{}' at [{},{}]. Setting target cell to blank.",
                             cellType, hssfCell.getRowIndex(), hssfCell.getColumnIndex());
                    xssfCell.setBlank();
            }
        }
    }

    // Pass XSSFCell to check its (already copied) style for date format
    private void copyNumericCellValue(HSSFCell hssfCell, XSSFCell xssfCell) {
        double numericValue = hssfCell.getNumericCellValue();
        // Check the TARGET cell's style, which should have been copied already
        if (DateUtil.isCellDateFormatted(xssfCell)) { // Check XSSFCell with copied style
            try {
                xssfCell.setCellValue(hssfCell.getDateCellValue());
            } catch (Exception e) {
                log.warn("Could not format numeric value {} as date at HSSF[{},{}], despite style indicating date format. Copying as number. Error: {}",
                         numericValue, hssfCell.getRowIndex(), hssfCell.getColumnIndex(), e.getMessage());
                xssfCell.setCellValue(numericValue);
            }
        } else {
            xssfCell.setCellValue(numericValue);
        }
    }


    private void copyCachedFormulaValue(HSSFCell hssfCell, XSSFCell xssfCell) {
         try {
            CellType cachedType = hssfCell.getCachedFormulaResultType();
            log.debug("Copying cached formula value of type {} for HSSF[{},{}]",
                     cachedType, hssfCell.getRowIndex(), hssfCell.getColumnIndex());
            switch (cachedType) {
                case STRING:
                    xssfCell.setCellValue(hssfCell.getStringCellValue());
                    break;
                case NUMERIC:
                    copyNumericCellValue(hssfCell, xssfCell); // Reuse numeric/date handling
                     break;
                case BOOLEAN:
                    xssfCell.setCellValue(hssfCell.getBooleanCellValue());
                    break;
                case ERROR:
                    xssfCell.setCellErrorValue(hssfCell.getErrorCellValue());
                    break;
                case BLANK:
                default:
                    xssfCell.setBlank();
                    break;
            }
         } catch (Exception e) {
              log.error("Error retrieving cached formula value for HSSF[{},{}]. Setting blank.",
                      hssfCell.getRowIndex(), hssfCell.getColumnIndex(), e);
             xssfCell.setBlank();
         }
    }


    // --- Cell Style Copying ---
    private XSSFCellStyle getOrCreateXSSFStyle(HSSFCellStyle hssfStyle, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook, HSSFPalette hssfPalette) {
        int hssfStyleIndex = hssfStyle.getIndex();

        if (styleMap.containsKey(hssfStyleIndex)) {
            return styleMap.get(hssfStyleIndex);
        }

        XSSFCellStyle xssfStyle = xssfWorkbook.createCellStyle();
        try {
            // Alignment, Borders (Style), Fill Pattern...
            xssfStyle.setAlignment(hssfStyle.getAlignment());
            xssfStyle.setVerticalAlignment(hssfStyle.getVerticalAlignment());
            xssfStyle.setBorderBottom(hssfStyle.getBorderBottom());
            xssfStyle.setBorderLeft(hssfStyle.getBorderLeft());
            xssfStyle.setBorderRight(hssfStyle.getBorderRight());
            xssfStyle.setBorderTop(hssfStyle.getBorderTop());
            xssfStyle.setFillPattern(hssfStyle.getFillPattern());

            // Border Colors
            HSSFColor bottomBorderHSSFColor = hssfPalette.getColor(hssfStyle.getBottomBorderColor());
            xssfStyle.setBottomBorderColor(convertToXSSFColor(bottomBorderHSSFColor, hssfPalette));
            HSSFColor leftBorderHSSFColor = hssfPalette.getColor(hssfStyle.getLeftBorderColor());
            xssfStyle.setLeftBorderColor(convertToXSSFColor(leftBorderHSSFColor, hssfPalette));
            HSSFColor rightBorderHSSFColor = hssfPalette.getColor(hssfStyle.getRightBorderColor());
            xssfStyle.setRightBorderColor(convertToXSSFColor(rightBorderHSSFColor, hssfPalette));
            HSSFColor topBorderHSSFColor = hssfPalette.getColor(hssfStyle.getTopBorderColor());
            xssfStyle.setTopBorderColor(convertToXSSFColor(topBorderHSSFColor, hssfPalette));

            // Fill Colors
            HSSFColor fillForegroundHSSFColor = hssfPalette.getColor(hssfStyle.getFillForegroundColor());
            xssfStyle.setFillForegroundColor(convertToXSSFColor(fillForegroundHSSFColor, hssfPalette)); // Pass even if null
            HSSFColor fillBackgroundHSSFColor = hssfPalette.getColor(hssfStyle.getFillBackgroundColor());
            xssfStyle.setFillBackgroundColor(convertToXSSFColor(fillBackgroundHSSFColor, hssfPalette)); // Pass even if null


            // Font
            HSSFFont hssfFont = hssfStyle.getFont(hssfWorkbook);
            if (hssfFont != null) {
                XSSFFont xssfFont = getOrCreateXSSFFont(hssfFont, hssfWorkbook, xssfWorkbook, hssfPalette);
                if (xssfFont != null) {
                    xssfStyle.setFont(xssfFont);
                }
            }

            // Data Format
             copyDataFormat(hssfStyle, xssfStyle, xssfWorkbook);

            // Other properties
            xssfStyle.setHidden(hssfStyle.getHidden());
            xssfStyle.setLocked(hssfStyle.getLocked());
            xssfStyle.setWrapText(hssfStyle.getWrapText());
            xssfStyle.setIndention(hssfStyle.getIndention());
            xssfStyle.setRotation(hssfStyle.getRotation());

            styleMap.put(hssfStyleIndex, xssfStyle);
            return xssfStyle;

        } catch (Exception e) {
            log.error("Failed to copy HSSFCellStyle index {} to XSSFCellStyle. Error: {}", hssfStyleIndex, e.getMessage(), e);
            return null;
        }
    }

     // --- Data Format Copying ---
     private void copyDataFormat(HSSFCellStyle hssfStyle, XSSFCellStyle xssfStyle, XSSFWorkbook xssfWorkbook) {
         try {
             short hssfDataFormatIndex = hssfStyle.getDataFormat();
             String hssfDataFormatString = hssfStyle.getDataFormatString();
             if (hssfDataFormatString != null && !hssfDataFormatString.equalsIgnoreCase("General")) {
                 XSSFDataFormat xssfDataFormat = xssfWorkbook.createDataFormat();
                 xssfStyle.setDataFormat(xssfDataFormat.getFormat(hssfDataFormatString));
             } else {
                 xssfStyle.setDataFormat(hssfDataFormatIndex);
                 log.trace("Using HSSF data format index {} directly for XSSF style.", hssfDataFormatIndex);
             }
         } catch (Exception e) {
             log.warn("Could not copy data format for HSSF style index {}. Error: {}", hssfStyle.getIndex(), e.getMessage());
         }
     }


     // --- Font Copying ---
    private XSSFFont getOrCreateXSSFFont(HSSFFont hssfFont, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook, HSSFPalette hssfPalette) {
        // FIX 1: Use int for local variable, cast to short for map key
        int hssfFontIndexInt = hssfFont.getIndexAsInt(); // Get index as int
        short hssfFontIndexShort = (short) hssfFontIndexInt; // Cast for map key

        // Check cache using the short key
        if (fontMap.containsKey(hssfFontIndexShort)) {
            return fontMap.get(hssfFontIndexShort);
        }

        XSSFFont xssfFont = xssfWorkbook.createFont();
        try {
            xssfFont.setFontName(hssfFont.getFontName());
            xssfFont.setFontHeightInPoints(hssfFont.getFontHeightInPoints());
            xssfFont.setBold(hssfFont.getBold());
            xssfFont.setItalic(hssfFont.getItalic());
            xssfFont.setStrikeout(hssfFont.getStrikeout());
            xssfFont.setUnderline(hssfFont.getUnderline());
            xssfFont.setTypeOffset(hssfFont.getTypeOffset());

            // Font Color
            HSSFColor hssfColor = hssfFont.getHSSFColor(hssfWorkbook);
            xssfFont.setColor(convertToXSSFColor(hssfColor, hssfPalette)); // Pass even if null

            // Cache using the short key
            fontMap.put(hssfFontIndexShort, xssfFont);
            return xssfFont;
        } catch (Exception e) {
             // Log using the int index for clarity if needed
             log.error("Failed to copy HSSFFont index {} to XSSFFont. Error: {}", hssfFontIndexInt, e.getMessage(), e);
             return null;
        }
    }

    // --- Color Conversion Utility ---
    private XSSFColor convertToXSSFColor(HSSFColor hssfColor, HSSFPalette hssfPalette) {
        if (hssfColor == null || hssfColor.getIndex() == HSSFColor.HSSFColorPredefined.AUTOMATIC.getIndex()) {
            return null; // Handle null input and Automatic color index -> default XSSF handling
        }
        short[] tripletShort = hssfColor.getTriplet();
        if (tripletShort == null) {
             log.warn("HSSFColor index {} provided null RGB triplet. Cannot convert.", hssfColor.getIndex());
             return null;
        }
        byte[] rgbBytes = new byte[] { (byte) tripletShort[0], (byte) tripletShort[1], (byte) tripletShort[2] };
        try {
            return new XSSFColor(rgbBytes, null); // Use default color map
        } catch (Exception e) {
            log.warn("Failed to create XSSFColor from RGB ({},{},{}) derived from HSSF index {}. Error: {}",
                     rgbBytes[0], rgbBytes[1], rgbBytes[2], hssfColor.getIndex(), e.getMessage());
            return null;
        }
    }


    // --- Merged Regions Copying ---
    private void copyMergedRegions(HSSFSheet hssfSheet, XSSFSheet xssfSheet) {
        int numMergedRegions = hssfSheet.getNumMergedRegions();
        if (numMergedRegions == 0) return;
        log.debug("Copying {} merged regions for sheet '{}'", numMergedRegions, xssfSheet.getSheetName());
        for (int i = 0; i < numMergedRegions; i++) {
            CellRangeAddress mergedRegion = null;
            try {
                 mergedRegion = hssfSheet.getMergedRegion(i);
                 if (mergedRegion != null) {
                    xssfSheet.addMergedRegion(mergedRegion);
                 } else {
                     log.warn("HSSFSheet.getMergedRegion({}) returned null on sheet '{}'. Skipping.", i, hssfSheet.getSheetName());
                 }
            } catch (IllegalArgumentException | RecordFormatException e) {
                String regionStr = (mergedRegion != null) ? mergedRegion.formatAsString() : "index " + i;
                log.warn("Could not add merged region {} to sheet '{}'. Skipping. Error: {}",
                    regionStr, xssfSheet.getSheetName(), e.getMessage());
            } catch (Exception e) {
                 String regionStr = (mergedRegion != null) ? mergedRegion.formatAsString() : "index " + i;
                 log.error("Unexpected error processing merged region {} on sheet '{}'. Skipping.",
                    regionStr, xssfSheet.getSheetName(), e);
            }
        }
    }

    // --- Column Width and Hidden Status Copying ---
    private void copyColumnWidths(HSSFSheet hssfSheet, XSSFSheet xssfSheet) {
        int maxCol = 0;
        for (Row row : hssfSheet) {
            if (row != null && row.getLastCellNum() >= 0) {
                 maxCol = Math.max(maxCol, row.getLastCellNum());
            }
        }
        log.debug("Max column index determined as {} for width copying on sheet '{}'", maxCol, xssfSheet.getSheetName());
        for (int colNum = 0; colNum < maxCol; colNum++) {
            int width = hssfSheet.getColumnWidth(colNum);
            int defaultCharWidth = hssfSheet.getDefaultColumnWidth();
            int defaultWidthUnits = defaultCharWidth * 256;
            if (width != defaultWidthUnits && width >= 0) {
                 int clampedWidth = Math.min(width, 65280);
                 if (width > 65280) {
                     log.warn("HSSF column {} width {} exceeds XLSX maximum (65280). Clamping.", colNum, width);
                 }
                 xssfSheet.setColumnWidth(colNum, clampedWidth);
            }
            if (hssfSheet.isColumnHidden(colNum)) {
                xssfSheet.setColumnHidden(colNum, true);
            }
        }
        xssfSheet.setDefaultColumnWidth(hssfSheet.getDefaultColumnWidth());
        log.debug("Copied column widths/hidden status and default width for sheet '{}'", xssfSheet.getSheetName());
    }


    // --- Cell Comment Copying ---
    private void copyCellComment(HSSFComment hssfComment, XSSFCell xssfCell) {
        if (hssfComment == null || xssfCell == null) return;
        XSSFSheet xssfSheet = xssfCell.getSheet();
        XSSFDrawing drawing = xssfSheet.getDrawingPatriarch();
        if (drawing == null) {
            drawing = xssfSheet.createDrawingPatriarch();
        }
        ClientAnchor anchor = hssfComment.getAnchor();
        XSSFClientAnchor xssfAnchor;
        if (anchor instanceof HSSFClientAnchor) {
            HSSFClientAnchor hssfAnchor = (HSSFClientAnchor) anchor;
             xssfAnchor = drawing.createAnchor(
                    hssfAnchor.getDx1(), hssfAnchor.getDy1(), hssfAnchor.getDx2(), hssfAnchor.getDy2(),
                    hssfAnchor.getCol1(), hssfAnchor.getRow1(), hssfAnchor.getCol2(), hssfAnchor.getRow2());
        } else {
            log.warn("Comment anchor at HSSF[{},{}] was not HSSFClientAnchor (type: {}). Using default position.",
                     xssfCell.getRowIndex(), xssfCell.getColumnIndex(), anchor != null ? anchor.getClass().getName() : "null");
            xssfAnchor = drawing.createAnchor(0, 0, 0, 0, xssfCell.getColumnIndex(), xssfCell.getRowIndex(), xssfCell.getColumnIndex() + 2, xssfCell.getRowIndex() + 3);
        }
        XSSFComment xssfComment = drawing.createCellComment(xssfAnchor);
        RichTextString hssfRichText = hssfComment.getString();
        if (hssfRichText != null) {
            // Simplified text copy - full rich text requires more context
            xssfComment.setString(new XSSFRichTextString(hssfRichText.getString()));
        } else {
            xssfComment.setString(new XSSFRichTextString(""));
        }
        try {
            xssfComment.setAuthor(hssfComment.getAuthor());
        } catch (Exception e) { /* Ignore */ }
        xssfComment.setVisible(hssfComment.isVisible());
        xssfCell.setCellComment(xssfComment);
    }


    // --- Hyperlink Copying ---
    private void copyHyperlink(HSSFHyperlink hssfLink, XSSFCell xssfCell) {
        if (hssfLink == null || xssfCell == null) return;

        XSSFWorkbook xssfWorkbook = xssfCell.getSheet().getWorkbook();
        XSSFCreationHelper helper = xssfWorkbook.getCreationHelper();
        XSSFHyperlink xssfLink = null;

        try {
            // FIX 3: Use getType() which returns the enum directly
            HyperlinkType linkType = hssfLink.getType(); // Get the enum value
            if (linkType == null) {
                log.warn("HSSFHyperlink type returned null at HSSF[{},{}]. Skipping.",
                        xssfCell.getRowIndex(), xssfCell.getColumnIndex());
                return;
            }

            xssfLink = helper.createHyperlink(linkType); // Use the enum value
            xssfLink.setAddress(hssfLink.getAddress());

            // FIX 2: Ensure CellRangeAddress is imported and add null check for safety
            CellRangeAddress address = new CellRangeAddress(
                    xssfCell.getRowIndex(), xssfCell.getRowIndex(),
                    xssfCell.getColumnIndex(), xssfCell.getColumnIndex());

            // Check if hyperlink was created successfully before setting reference
            if (xssfLink != null) {
                 xssfLink.setCellReference(address.formatAsString()); // Should work if imports ok

                 if (hssfLink.getLabel() != null) {
                     xssfLink.setLabel(hssfLink.getLabel());
                 }
                 xssfCell.setHyperlink(xssfLink);
                 applyDefaultHyperlinkStyleIfNeeded(xssfCell, xssfWorkbook);
            } else {
                log.warn("Failed to create XSSFHyperlink object for type {} at HSSF[{},{}].",
                         linkType, xssfCell.getRowIndex(), xssfCell.getColumnIndex());
            }

        } catch (Exception e) {
            log.error("Failed to copy hyperlink from HSSF[{},{}] address='{}'. Error: {}",
                    xssfCell.getRowIndex(), xssfCell.getColumnIndex(), hssfLink.getAddress(), e.getMessage(), e);
        }
    }

    // --- Hyperlink Style Helper ---
    private void applyDefaultHyperlinkStyleIfNeeded(XSSFCell cell, XSSFWorkbook workbook) {
         CellStyle currentStyle = cell.getCellStyle();
         boolean needsDefaultStyle = false;
         if (currentStyle == null) {
             needsDefaultStyle = true;
         } else {
             Font currentFont = workbook.getFontAt(currentStyle.getFontIndex());
             if (currentFont.getUnderline() == Font.U_NONE || currentFont.getColor() != IndexedColors.BLUE.getIndex()) {
                 needsDefaultStyle = true;
             }
         }
         if (needsDefaultStyle) {
             if (this.defaultHyperlinkStyle == null) {
                 this.defaultHyperlinkStyle = createDefaultHyperlinkStyle(workbook);
             }
             if (this.defaultHyperlinkStyle != null) {
                 cell.setCellStyle(this.defaultHyperlinkStyle);
             }
         }
    }

    // Creates the default hyperlink style
    private XSSFCellStyle createDefaultHyperlinkStyle(XSSFWorkbook workbook) {
        try {
            XSSFCellStyle style = workbook.createCellStyle();
            XSSFFont font = workbook.createFont();
            font.setUnderline(Font.U_SINGLE);
            font.setColor(IndexedColors.BLUE.getIndex());
            style.setFont(font);
            return style;
        } catch (Exception e) {
            log.error("Failed to create default hyperlink style.", e);
            return null;
        }
    }
}
```

**总结修正点:**

1.  **~L406 (`getOrCreateXSSFFont`):** `hssfFont.getIndexAsInt()` 返回 `int`，本地变量 `hssfFontIndexInt` 现在是 `int` 类型。在操作 `fontMap`（其键是 `Short`）时，使用 `(short)hssfFontIndexInt` 进行类型转换。
2.  **~L550 (`copyHyperlink`):** 添加了对 `xssfLink` 对象的空值检查，以防 `helper.createHyperlink` 失败。确保 `org.apache.poi.ss.util.CellRangeAddress` 被正确导入。`setCellReference` 接收 `String`，`formatAsString` 返回 `String`，类型匹配本身没有问题。
3.  **~L614 (`copyHyperlink`):** 将 `hssfLink.getTypeEnum()` 更改为正确的 `hssfLink.getType()`，它直接返回 `HyperlinkType` 枚举。后续不再需要 `switch` 语句来转换类型。

请再次检查这些修正是否解决了您遇到的具体错误。