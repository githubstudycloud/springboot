Okay, let's create a Spring Boot 2.7 (with Java 8) REST endpoint that accepts an `.xls` file, converts it to `.xlsx`, and attempts to preserve both data and cell styling using the Apache POI library.

**1. Project Setup (pom.xml)**

Make sure you have the necessary dependencies in your `pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version> <relativePath/> </parent>
    <groupId>com.example</groupId>
    <artifactId>xls-to-xlsx-converter</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>xls-to-xlsx-converter</name>
    <description>XLS to XLSX Converter with Style Preservation</description>

    <properties>
        <java.version>1.8</java.version>
        <poi.version>5.2.5</poi.version> </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>${poi.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${poi.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
            <version>4.4</version>
        </dependency>
        <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
             <version>1.26.1</version> </dependency>
         <dependency>
             <groupId>com.github.virtuald</groupId>
             <artifactId>curvesapi</artifactId>
             <version>1.08</version> </dependency>


        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

**2. Service Layer (ExcelConversionService.java)**

This service will contain the core conversion logic. Preserving styles requires careful copying of style attributes.

```java
package com.example.xlstoxlsxconverter.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.poi.hssf.usermodel.*;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@Service
@Slf4j // Using Lombok for logging
public class ExcelConversionService {

    // Cache to avoid creating duplicate styles, which can bloat the XLSX file
    private final Map<Integer, XSSFCellStyle> styleMap = new HashMap<>();
    private final Map<Short, XSSFFont> fontMap = new HashMap<>(); // Cache for fonts

    public byte[] convertXlsToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }

        String originalFilename = file.getOriginalFilename();
        if (originalFilename == null || !originalFilename.toLowerCase().endsWith(".xls")) {
             log.warn("Input file might not be an XLS file: {}", originalFilename);
             // Consider adding stricter validation if needed
        }

        styleMap.clear(); // Clear cache for each conversion
        fontMap.clear();

        try (InputStream inputStream = file.getInputStream();
             HSSFWorkbook hssfWorkbook = new HSSFWorkbook(inputStream); // Read XLS
             XSSFWorkbook xssfWorkbook = new XSSFWorkbook(); // Create XLSX
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            log.info("Starting conversion for file: {}", originalFilename);

            // Copy sheets
            for (int i = 0; i < hssfWorkbook.getNumberOfSheets(); i++) {
                HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(i);
                XSSFSheet xssfSheet = xssfWorkbook.createSheet(hssfSheet.getSheetName());
                log.debug("Processing sheet: {}", hssfSheet.getSheetName());

                // Copy merged regions
                copyMergedRegions(hssfSheet, xssfSheet);

                // Copy rows and cells
                copyRowsAndCells(hssfSheet, xssfSheet, hssfWorkbook, xssfWorkbook);

                // Copy column widths (do this after copying cells)
                copyColumnWidths(hssfSheet, xssfSheet);
            }

            // Copy custom colors (if any) - less common but possible
            copyCustomColors(hssfWorkbook, xssfWorkbook);


            xssfWorkbook.write(baos);
            log.info("Conversion successful for file: {}", originalFilename);
            return baos.toByteArray();

        } catch (Exception e) {
            log.error("Error during XLS to XLSX conversion for file: {}", originalFilename, e);
            // Re-throwing IOException or a custom exception is often appropriate here
            throw new IOException("Conversion failed: " + e.getMessage(), e);
        } finally {
             styleMap.clear(); // Ensure cleanup even on error
             fontMap.clear();
        }
    }

    private void copyRowsAndCells(HSSFSheet hssfSheet, XSSFSheet xssfSheet, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook) {
        int maxColNum = 0;
        for (int rowIndex = hssfSheet.getFirstRowNum(); rowIndex <= hssfSheet.getLastRowNum(); rowIndex++) {
            HSSFRow hssfRow = hssfSheet.getRow(rowIndex);
            if (hssfRow == null) {
                continue; // Skip empty rows
            }
            XSSFRow xssfRow = xssfSheet.createRow(rowIndex);

            // Copy row height
            xssfRow.setHeight(hssfRow.getHeight());
            // Copy other row properties if needed (e.g., styles - less common for rows)

            for (int colIndex = hssfRow.getFirstCellNum(); colIndex < hssfRow.getLastCellNum(); colIndex++) {
                 HSSFCell hssfCell = hssfRow.getCell(colIndex);
                 if (hssfCell == null) {
                     continue; // Skip empty cells within a row
                 }
                 XSSFCell xssfCell = xssfRow.createCell(colIndex, hssfCell.getCellType());

                 // Copy cell value
                 copyCellValue(hssfCell, xssfCell);

                 // Copy cell style (most complex part)
                 if (hssfCell.getCellStyle() != null) {
                      HSSFCellStyle hssfStyle = hssfCell.getCellStyle();
                      XSSFCellStyle xssfStyle = getOrCreateXSSFStyle(hssfStyle, hssfWorkbook, xssfWorkbook);
                      if (xssfStyle != null) {
                         xssfCell.setCellStyle(xssfStyle);
                      }
                 }

                 // Copy cell comments
                 if (hssfCell.getCellComment() != null) {
                      copyCellComment(hssfCell, xssfCell);
                 }
                 maxColNum = Math.max(maxColNum, colIndex + 1); // Track max columns used
            }
        }
         log.debug("Finished copying rows/cells for sheet '{}'. Max columns: {}", xssfSheet.getSheetName(), maxColNum);
    }

    private void copyCellValue(HSSFCell hssfCell, XSSFCell xssfCell) {
        switch (hssfCell.getCellType()) {
            case STRING:
                xssfCell.setCellValue(hssfCell.getStringCellValue());
                break;
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(hssfCell)) {
                    xssfCell.setCellValue(hssfCell.getDateCellValue());
                } else {
                    xssfCell.setCellValue(hssfCell.getNumericCellValue());
                }
                break;
            case BOOLEAN:
                xssfCell.setCellValue(hssfCell.getBooleanCellValue());
                break;
            case FORMULA:
                 try {
                     xssfCell.setCellFormula(hssfCell.getCellFormula());
                 } catch (Exception e) {
                      // Formula parsing can fail sometimes. Log and potentially set as string value.
                      log.warn("Could not copy formula '{}' from HSSF to XSSF at row {}, col {}. Setting as string value. Error: {}",
                              hssfCell.getCellFormula(), hssfCell.getRowIndex(), hssfCell.getColumnIndex(), e.getMessage());
                      try {
                          xssfCell.setCellValue(hssfCell.getStringCellValue()); // Fallback to cached string value if possible
                      } catch (Exception ignored) {
                          // If cannot get string value either, leave it blank or set an error marker
                           xssfCell.setBlank(); // Or set an error value
                      }
                 }
                break;
            case BLANK:
                xssfCell.setBlank();
                break;
            case ERROR:
                xssfCell.setCellErrorValue(hssfCell.getErrorCellValue());
                break;
            default:
                // Should not happen
                log.warn("Unhandled HSSF cell type: {}", hssfCell.getCellType());
                xssfCell.setBlank();
        }
    }


    private XSSFCellStyle getOrCreateXSSFStyle(HSSFCellStyle hssfStyle, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook) {
        int hssfStyleHash = hssfStyle.getIndex(); // Use index as a simple hash key

        if (styleMap.containsKey(hssfStyleHash)) {
            return styleMap.get(hssfStyleHash);
        }

        // Style not in cache, create a new one
        XSSFCellStyle xssfStyle = xssfWorkbook.createCellStyle();

        // --- Core Style Copying Logic ---

        // Alignment
        xssfStyle.setAlignment(hssfStyle.getAlignment());
        xssfStyle.setVerticalAlignment(hssfStyle.getVerticalAlignment());

        // Borders
        xssfStyle.setBorderBottom(hssfStyle.getBorderBottom());
        xssfStyle.setBorderLeft(hssfStyle.getBorderLeft());
        xssfStyle.setBorderRight(hssfStyle.getBorderRight());
        xssfStyle.setBorderTop(hssfStyle.getBorderTop());

        // Border Colors (needs HSSFPalette -> XSSFColor conversion)
        HSSFPalette hssfPalette = hssfWorkbook.getCustomPalette();
        xssfStyle.setBottomBorderColor(convertToXSSFColor(hssfStyle.getBottomBorderColorColor(), hssfPalette));
        xssfStyle.setLeftBorderColor(convertToXSSFColor(hssfStyle.getLeftBorderColorColor(), hssfPalette));
        xssfStyle.setRightBorderColor(convertToXSSFColor(hssfStyle.getRightBorderColorColor(), hssfPalette));
        xssfStyle.setTopBorderColor(convertToXSSFColor(hssfStyle.getTopBorderColorColor(), hssfPalette));

        // Fill (Pattern and Colors)
        xssfStyle.setFillPattern(hssfStyle.getFillPattern());
        xssfStyle.setFillForegroundColor(convertToXSSFColor(hssfStyle.getFillForegroundColorColor(), hssfPalette));
        xssfStyle.setFillBackgroundColor(convertToXSSFColor(hssfStyle.getFillBackgroundColorColor(), hssfPalette));

        // Font
        HSSFFont hssfFont = hssfStyle.getFont(hssfWorkbook);
        XSSFFont xssfFont = getOrCreateXSSFFont(hssfFont, hssfWorkbook, xssfWorkbook);
        xssfStyle.setFont(xssfFont);

        // Data Format
        xssfStyle.setDataFormat(copyDataFormat(hssfStyle, xssfWorkbook));


        // Other properties
        xssfStyle.setHidden(hssfStyle.getHidden());
        xssfStyle.setLocked(hssfStyle.getLocked());
        xssfStyle.setWrapText(hssfStyle.getWrapText());
        xssfStyle.setIndention(hssfStyle.getIndention());
        xssfStyle.setRotation(hssfStyle.getRotation());
        // xssfStyle.setShrinkToFit(...) // HSSF doesn't directly expose shrinkToFit in the same way

        // Cache the newly created style
        styleMap.put(hssfStyleHash, xssfStyle);
        return xssfStyle;
    }

     private XSSFFont getOrCreateXSSFFont(HSSFFont hssfFont, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook) {
        short hssfFontIdx = hssfFont.getIndex(); // Use index as key

        if (fontMap.containsKey(hssfFontIdx)) {
            return fontMap.get(hssfFontIdx);
        }

        XSSFFont xssfFont = xssfWorkbook.createFont();

        // Copy Font attributes
        xssfFont.setFontName(hssfFont.getFontName());
        xssfFont.setFontHeightInPoints(hssfFont.getFontHeightInPoints());
        xssfFont.setBold(hssfFont.getBold());
        xssfFont.setItalic(hssfFont.getItalic());
        xssfFont.setStrikeout(hssfFont.getStrikeout());
        xssfFont.setUnderline(hssfFont.getUnderline());
        xssfFont.setTypeOffset(hssfFont.getTypeOffset()); // Super/subscript

        // Font Color
        HSSFPalette hssfPalette = hssfWorkbook.getCustomPalette();
        xssfFont.setColor(convertToXSSFColor(hssfFont.getColorColor(), hssfPalette)); // Convert HSSFColor index

        // Cache the font
        fontMap.put(hssfFontIdx, xssfFont);
        return xssfFont;
    }


    private XSSFColor convertToXSSFColor(HSSFColor hssfColor, HSSFPalette palette) {
        if (hssfColor == null || hssfColor.getIndex() == HSSFColor.HSSFColorPredefined.AUTOMATIC.getIndex()) {
             // Handle automatic color (often default black or white depending on theme)
             // You might return null or a default XSSFColor like new XSSFColor(IndexedColors.AUTOMATIC, null)
             // Returning null often lets XSSF use its defaults, which is usually desired.
            return null; // Let XSSF handle automatic
        }

        // Attempt to get RGB from palette first (for custom colors)
        byte[] rgb = null;
        if (palette != null) {
            HSSFColor paletteColor = palette.getColor(hssfColor.getIndex());
            if (paletteColor != null) { // Check if the color exists in the palette
                short[] triplet = paletteColor.getTriplet();
                rgb = new byte[]{(byte) triplet[0], (byte) triplet[1], (byte) triplet[2]};
            }
        }


        // If not found in palette or no palette, use the predefined color's RGB
        if (rgb == null) {
            // Check against HSSFColorPredefined if it's a standard color
            HSSFColor.HSSFColorPredefined predefined = HSSFColor.HSSFColorPredefined.fromInt(hssfColor.getIndex());
            if (predefined != null) {
                short[] triplet = predefined.getTriplet();
                 rgb = new byte[]{(byte) triplet[0], (byte) triplet[1], (byte) triplet[2]};
            } else {
                // Fallback if it's neither in palette nor a standard predefined color
                // This might happen with very old files or corrupted palettes.
                // Default to black or log a warning.
                log.warn("Could not resolve HSSFColor index {}. Defaulting to black.", hssfColor.getIndex());
                short[] blackTriplet = HSSFColor.HSSFColorPredefined.BLACK.getTriplet();
                rgb = new byte[]{(byte) blackTriplet[0], (byte) blackTriplet[1], (byte) blackTriplet[2]};
            }
        }

        // Create XSSFColor with the determined RGB values
        // Use DefaultIndexedColorMap to map standard colors if possible, otherwise use RGB
        // IndexedColors indexedColor = // You could try mapping back standard RGB to IndexedColors
        // return new XSSFColor(indexedColor, new DefaultIndexedColorMap()); // This is complex

        // Simpler: Just use the RGB value directly. Most modern Excel versions handle this fine.
        return new XSSFColor(rgb, null); // null for DefaultIndexedColorMap

    }

     private short copyDataFormat(HSSFCellStyle hssfStyle, XSSFWorkbook xssfWorkbook) {
         short hssfDataFormatIndex = hssfStyle.getDataFormat();
         String hssfDataFormatString = hssfStyle.getDataFormatString();

         // XSSF uses the same mechanism but needs the format string
         XSSFDataFormat xssfDataFormat = xssfWorkbook.createDataFormat();
         return xssfDataFormat.getFormat(hssfDataFormatString);
     }


    private void copyMergedRegions(HSSFSheet hssfSheet, XSSFSheet xssfSheet) {
        for (int i = 0; i < hssfSheet.getNumMergedRegions(); i++) {
            CellRangeAddress mergedRegion = hssfSheet.getMergedRegion(i);
            try {
             xssfSheet.addMergedRegion(mergedRegion);
            } catch (IllegalArgumentException e) {
                log.warn("Could not add merged region {} to sheet '{}'. It might overlap with existing regions. Error: {}",
                    mergedRegion.formatAsString(), xssfSheet.getSheetName(), e.getMessage());
                // Decide how to handle overlap: skip, log, throw? Skipping is often safest.
            } catch (Exception e) {
                 log.error("Unexpected error adding merged region {} to sheet '{}'",
                    mergedRegion.formatAsString(), xssfSheet.getSheetName(), e);
            }
        }
    }

    private void copyColumnWidths(HSSFSheet hssfSheet, XSSFSheet xssfSheet) {
        // Find the maximum column index used in the sheet
        int maxCol = 0;
        for (Row row : hssfSheet) {
            if (row.getLastCellNum() > maxCol) {
                maxCol = row.getLastCellNum();
            }
        }

        for (int colNum = 0; colNum < maxCol; colNum++) {
            // POI column width is in units of 1/256th of a character width
            int width = hssfSheet.getColumnWidth(colNum);
            // Only copy if it's not the default width (avoids unnecessary settings)
            // HSSF default is 8 * 256. XSSF default is similar but might vary slightly.
             // Copying explicitly is generally safer.
            if (width != hssfSheet.getDefaultColumnWidth() * 256) {
                 xssfSheet.setColumnWidth(colNum, width);
            } else {
                // Optional: Explicitly set XSSF default if needed, though usually not necessary
                 // xssfSheet.setColumnWidth(colNum, xssfSheet.getDefaultColumnWidth() * 256);
            }
        }
        // Copy default column width
        xssfSheet.setDefaultColumnWidth(hssfSheet.getDefaultColumnWidth());
    }


    private void copyCellComment(HSSFCell hssfCell, XSSFCell xssfCell) {
        HSSFComment hssfComment = hssfCell.getCellComment();
        if (hssfComment == null) return;

        XSSFSheet xssfSheet = xssfCell.getSheet();
        XSSFDrawing drawing = xssfSheet.getDrawingPatriarch();
        if (drawing == null) {
            drawing = xssfSheet.createDrawingPatriarch();
        }

        // Client anchor defines position and size of the comment box
        // HSSF uses HSSFClientAnchor, XSSF uses XSSFClientAnchor
        // We need to create a new anchor for XSSF
        // HSSF anchor details might not translate perfectly, but we can try
        HSSFClientAnchor hssfAnchor = (HSSFClientAnchor) hssfComment.getAnchor();
        // Create a similar anchor for XSSF. Adjust dx/dy/col/row values if needed.
        XSSFClientAnchor xssfAnchor = drawing.createAnchor(
                hssfAnchor.getDx1(), hssfAnchor.getDy1(), hssfAnchor.getDx2(), hssfAnchor.getDy2(),
                hssfAnchor.getCol1(), hssfAnchor.getRow1(), hssfAnchor.getCol2(), hssfAnchor.getRow2());

        XSSFComment xssfComment = drawing.createCellComment(xssfAnchor);

        // Copy text (RichTextString preserves basic formatting like bold/italic if used)
        if (hssfComment.getString() != null) {
             // Create XSSFRichTextString from HSSFRichTextString
             HSSFRichTextString hssfRichText = hssfComment.getString();
             XSSFRichTextString xssfRichText = new XSSFRichTextString(hssfRichText.getString());

             // Attempt to copy basic formatting runs (bold, italic, etc.)
             // This is complex and might not be perfect
             for (int i = 0; i < hssfRichText.numFormattingRuns(); i++) {
                 short fontIndex = hssfRichText.getFontAtIndex(hssfRichText.getIndexOfFormattingRun(i));
                 if (fontIndex != HSSFRichTextString.NO_FONT) {
                     HSSFFont hssfRunFont = hssfCell.getSheet().getWorkbook().getFontAt(fontIndex);
                     XSSFFont xssfRunFont = getOrCreateXSSFFont(hssfRunFont, (HSSFWorkbook) hssfCell.getSheet().getWorkbook(), xssfCell.getSheet().getWorkbook());
                     // Apply the font to the corresponding part of the XSSF string
                     try {
                         xssfRichText.applyFont(hssfRichText.getIndexOfFormattingRun(i),
                                                hssfRichText.getLengthOfFormattingRun(i) + hssfRichText.getIndexOfFormattingRun(i),
                                                xssfRunFont);
                     } catch(Exception e) {
                         log.warn("Could not apply font formatting run to comment text.", e);
                     }
                 }
             }
             xssfComment.setString(xssfRichText);

        }
        // Copy author
        xssfComment.setAuthor(hssfComment.getAuthor());
        // Copy visibility
        xssfComment.setVisible(hssfComment.isVisible());

        xssfCell.setCellComment(xssfComment);
    }

     private void copyCustomColors(HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook) {
         HSSFPalette hssfPalette = hssfWorkbook.getCustomPalette();
         XSSFColorMap colorMap = xssfWorkbook.getStylesSource().getIndexedColors(); // Use XSSFColorMap for setting colors

         if (hssfPalette != null) {
             log.debug("Copying custom colors from HSSF palette.");
             // Iterate over potential custom color indices (usually start after predefined ones)
             // Standard colors usually occupy indices up to 64 (0x40)
             for (short i = 8; i < 64; i++) { // Indices 0-7 are often reserved/standard
                 HSSFColor hssfColor = hssfPalette.getColor(i);
                 if (hssfColor != null) {
                     short[] triplet = hssfColor.getTriplet();
                     // Check if this color is different from the default color at this index
                     // (This check is complex as defaults can vary slightly)
                     // Simplest approach: just try to set it in XSSF if it exists in HSSF palette
                     byte[] rgb = new byte[] {(byte)triplet[0], (byte)triplet[1], (byte)triplet[2]};
                     try {
                          // We cannot directly set indexed colors in XSSF in the same way as HSSF palette.
                          // XSSF uses a theme-based approach primarily.
                          // The best we can do is ensure our convertToXSSFColor function
                          // uses the RGB values from the HSSF palette when it encounters
                          // a custom color index during cell style conversion.
                          // There isn't a direct "xssfPalette.setColor(index, rgb)" equivalent.
                          log.trace("Custom HSSF color found at index {}: RGB({},{},{}) - will be used during style conversion.",
                                  i, triplet[0], triplet[1], triplet[2]);

                     } catch (Exception e) {
                         log.warn("Could not handle custom color mapping for index {}. Error: {}", i, e.getMessage());
                     }
                 }
             }
         }
     }
}
```

**3. Controller Layer (ExcelConversionController.java)**

This controller defines the REST endpoint.

```java
package com.example.xlstoxlsxconverter.controller;

import com.example.xlstoxlsxconverter.service.ExcelConversionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/convert")
@RequiredArgsConstructor // Lombok for constructor injection
@Slf4j
public class ExcelConversionController {

    private final ExcelConversionService excelConversionService;

    @PostMapping(value = "/xls-to-xlsx", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<byte[]> convertXlsToXlsx(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            log.warn("Received empty file upload request.");
            return ResponseEntity.badRequest().body("Please select a file to upload.".getBytes());
        }

        String originalFilename = file.getOriginalFilename();
        String outputFilename = "converted_file.xlsx"; // Default name
        if (originalFilename != null && !originalFilename.isEmpty()) {
            // Create a safer output filename based on the original
            String baseName = originalFilename.substring(0, Math.max(0, originalFilename.lastIndexOf('.')));
             // Sanitize baseName further if needed (remove special chars etc.)
            outputFilename = baseName + ".xlsx";
        }

        log.info("Received request to convert file: {}", originalFilename);

        try {
            byte[] xlsxBytes = excelConversionService.convertXlsToXlsx(file);

            HttpHeaders headers = new HttpHeaders();
            // Set appropriate content type for XLSX files
            headers.setContentType(MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"));
            // Set Content-Disposition to prompt download with the new filename
            // URL Encode the filename for better compatibility with browsers/special chars
            String encodedFilename = URLEncoder.encode(outputFilename, StandardCharsets.UTF_8.toString()).replace("+", "%20");
            headers.setContentDispositionFormData("attachment", encodedFilename);
            // headers.setContentDispositionFormData("attachment", outputFilename); // Simpler alternative if encoding issues arise

            headers.setContentLength(xlsxBytes.length);

            log.info("Successfully converted '{}' to '{}'. Sending response.", originalFilename, outputFilename);
            return new ResponseEntity<>(xlsxBytes, headers, HttpStatus.OK);

        } catch (IllegalArgumentException e) {
            log.warn("Bad request during conversion of {}: {}", originalFilename, e.getMessage());
            return ResponseEntity.badRequest().body(("Conversion error: " + e.getMessage()).getBytes());
        } catch (IOException e) {
            log.error("IO Error during conversion of {}: {}", originalFilename, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(("Failed to convert file due to an internal error: " + e.getMessage()).getBytes());
        } catch (Exception e) {
             log.error("Unexpected Error during conversion of {}: {}", originalFilename, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(("An unexpected error occurred during conversion.").getBytes());
        }
    }
}
```

**4. Main Application Class**

```java
package com.example.xlstoxlsxconverter;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class XlsToXlsxConverterApplication {

    public static void main(String[] args) {
        SpringApplication.run(XlsToXlsxConverterApplication.class, args);
    }

}
```

**Explanation and Key Points:**

1.  **Dependencies:** Apache POI (`poi` for HSSF/XLS and `poi-ooxml` for XSSF/XLSX) is essential. Commons Collections, Compress, and CurvesAPI are often needed by POI for full functionality.
2.  **Controller:** A standard Spring `@RestController` handles the `/api/convert/xls-to-xlsx` POST request. It accepts a `MultipartFile`.
3.  **Service (`ExcelConversionService`):**
    * Reads the input `.xls` file using `HSSFWorkbook`.
    * Creates a new `XSSFWorkbook` for the output.
    * Iterates through sheets, rows, and cells of the source `HSSFWorkbook`.
    * For each corresponding element (sheet, row, cell) in the target `XSSFWorkbook`:
        * **Copies Values:** Handles different cell types (String, Numeric, Boolean, Formula, Date, etc.).
        * **Copies Styles (`getOrCreateXSSFStyle`):** This is the core of preserving appearance.
            * It takes an `HSSFCellStyle` and creates/retrieves a corresponding `XSSFCellStyle`.
            * **Caching (`styleMap`, `fontMap`):** Crucial for performance and to avoid exceeding Excel's style limits. It maps HSSF style/font indices to already created XSSF style/font objects.
            * **Attribute Copying:** Manually copies properties like alignment, borders, fill patterns, fill colors, fonts, and data formats.
            * **Color Conversion (`convertToXSSFColor`):** Translates `HSSFColor` (often palette-indexed) to `XSSFColor` (often RGB-based). It handles standard colors, custom palette colors, and the "automatic" color.
            * **Font Conversion (`getOrCreateXSSFFont`):** Similar to style copying, it copies font attributes (name, size, bold, italic, color, etc.) and uses caching.
        * **Copies Merged Regions:** Uses `CellRangeAddress`.
        * **Copies Column Widths:** Important for layout.
        * **Copies Cell Comments:** Recreates comments with text, author, and anchor position. Tries to preserve basic text formatting within comments.
    * Writes the final `XSSFWorkbook` to a `ByteArrayOutputStream`.
4.  **Response:** The controller sets the correct `Content-Type` for `.xlsx` files and the `Content-Disposition` header to make the browser download the file with the new `.xlsx` extension.
5.  **Error Handling:** Basic error handling is included for file IO, invalid input, and unexpected errors during conversion.
6.  **Java 8:** The code uses Java 8 features like try-with-resources.
7.  **Style Fidelity:** While this code copies many common style attributes, perfect 1:1 style conversion between HSSF and XSSF is challenging due to differences in the formats (e.g., advanced conditional formatting, theme colors, certain shape properties might not transfer perfectly). This implementation covers the most common styling elements. Macros (.xls/.xlsm) are **not** copied.

**How to Run:**

1.  Build the project using Maven: `mvn clean package`
2.  Run the Spring Boot application: `java -jar target/xls-to-xlsx-converter-0.0.1-SNAPSHOT.jar`
3.  Use a tool like Postman or `curl` to send a POST request to `http://localhost:8080/api/convert/xls-to-xlsx` with the `form-data` body containing a key named `file` and your `.xls` file as the value.

The response will be the converted `.xlsx` file data, which your client/browser should prompt you to download.