您是对的，非常抱歉之前的代码中出现了`getColorColor`这样错误的、不存在的方法名。这显然是我的疏忽。获取颜色的正确方式通常是先获取颜色的索引（一个`short`类型的值），然后使用`HSSFPalette`来将这个索引解析成一个`HSSFColor`对象，最后再进行转换。

我已经仔细检查并重写了`ExcelConversionService`，特别是修正了所有与颜色相关的逻辑（边框、填充、字体），并再次确认了之前提到的其他问题点（如公式处理、批注锚点等）。

以下是修正后的完整`ExcelConversionService.java`代码：

```java
package com.example.xlstoxlsxconverter.service;

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI Base (Shared) imports
import org.apache.poi.common.usermodel.HyperlinkType; // Use common HyperlinkType
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.util.RecordFormatException; // For formula parsing issues
import org.apache.poi.ss.formula.FormulaParseException; // More specific formula exception

// Apache POI HSSF (.xls) specific imports
import org.apache.poi.hssf.usermodel.*;
import org.apache.poi.hssf.util.HSSFColor;

// Apache POI XSSF (.xlsx) specific imports
import org.apache.poi.xssf.usermodel.*;
// No longer need XSSFCellBorder/Fill explicitly here

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
// No need for Objects import if not used

@Service
@Slf4j // Using Lombok for logging
public class ExcelConversionService {

    // Caches for styles and fonts to improve performance and avoid excessive object creation.
    // Using simple HashMaps, consider WeakHashMap if memory pressure is a concern.
    private final Map<Integer, XSSFCellStyle> styleMap = new HashMap<>();
    private final Map<Short, XSSFFont> fontMap = new HashMap<>();
    // Cache for default hyperlink style
    private XSSFCellStyle defaultHyperlinkStyle = null;


    public byte[] convertXlsToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }

        String originalFilename = file.getOriginalFilename();
        log.info("Received request to convert file: {}", originalFilename);
        if (originalFilename == null || !originalFilename.toLowerCase().endsWith(".xls")) {
             log.warn("Input file might not be an XLS file (based on extension): {}", originalFilename);
             // Consider adding stricter content-type validation if needed, but be aware it can be unreliable.
        }

        // Clear caches for this conversion request
        styleMap.clear();
        fontMap.clear();
        defaultHyperlinkStyle = null; // Reset cached hyperlink style


        try (InputStream inputStream = file.getInputStream();
             // Read the source XLS workbook
             HSSFWorkbook hssfWorkbook = new HSSFWorkbook(inputStream);
             // Create the target XLSX workbook
             XSSFWorkbook xssfWorkbook = new XSSFWorkbook();
             // Output stream for the resulting XLSX data
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            log.info("Starting XLS to XLSX conversion process for: {}", originalFilename);

            int numberOfSheets = hssfWorkbook.getNumberOfSheets();
            log.debug("Source workbook contains {} sheets.", numberOfSheets);

            // Get the palette for color lookups (crucial for HSSF)
            HSSFPalette hssfPalette = hssfWorkbook.getCustomPalette();

            // Iterate through and copy each sheet
            for (int i = 0; i < numberOfSheets; i++) {
                HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(i);
                // Optionally skip hidden sheets
                // if (hssfWorkbook.isSheetHidden(i) || hssfWorkbook.isSheetVeryHidden(i)) continue;

                XSSFSheet xssfSheet = xssfWorkbook.createSheet(hssfSheet.getSheetName());
                log.debug("Processing sheet: '{}' (Index {})", hssfSheet.getSheetName(), i);

                // 1. Copy Merged Regions (do this early)
                copyMergedRegions(hssfSheet, xssfSheet);

                // 2. Copy Rows and Cells (includes values, styles, comments, hyperlinks)
                copyRowsAndCells(hssfSheet, xssfSheet, hssfWorkbook, xssfWorkbook, hssfPalette);

                // 3. Copy Column Widths and Hidden Status (after rows/cells are processed)
                copyColumnWidths(hssfSheet, xssfSheet);

                // 4. Optional: Copy sheet settings (protection, print settings, etc. - requires more code)
                // copySheetProtection(hssfSheet, xssfSheet);
                // copyPrintSettings(hssfSheet, xssfSheet);
            }

            // Write the completed XLSX workbook to the output stream
            xssfWorkbook.write(baos);
            log.info("Successfully converted file: {}", originalFilename);
            return baos.toByteArray();

        } catch (IOException ioe) {
            log.error("IO Error during conversion for file: {}", originalFilename, ioe);
            throw ioe; // Re-throw IOExceptions
        } catch (RecordFormatException | FormulaParseException rfe) {
            // Catch specific POI exceptions related to file format or formula issues
             log.error("Error processing file format or formula in {}. File might be corrupted or contain unsupported features.", originalFilename, rfe);
             throw new IOException("Conversion failed due to format/formula issue: " + rfe.getMessage(), rfe);
        }
        catch (Exception e) {
            log.error("Unexpected error during conversion for file: {}", originalFilename, e);
            throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e);
        } finally {
             // Ensure caches are cleared even if an error occurs
             styleMap.clear();
             fontMap.clear();
             defaultHyperlinkStyle = null;
             log.debug("Cleared conversion caches.");
        }
    }

    // --- Core Row and Cell Copying Logic ---
    private void copyRowsAndCells(HSSFSheet hssfSheet, XSSFSheet xssfSheet, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook, HSSFPalette hssfPalette) {
        int maxColNum = 0; // Track max column for width copying

        for (int rowIndex = hssfSheet.getFirstRowNum(); rowIndex <= hssfSheet.getLastRowNum(); rowIndex++) {
            HSSFRow hssfRow = hssfSheet.getRow(rowIndex);
            if (hssfRow == null) continue; // Skip null rows

            XSSFRow xssfRow = xssfSheet.createRow(rowIndex);
            copyRowProperties(hssfRow, xssfRow); // Copy height, zero-height status, etc.

            for (int colIndex = hssfRow.getFirstCellNum(); colIndex >= 0 && colIndex < hssfRow.getLastCellNum(); colIndex++) {
                 HSSFCell hssfCell = hssfRow.getCell(colIndex);
                 if (hssfCell == null) continue; // Skip null cells

                 XSSFCell xssfCell = xssfRow.createCell(colIndex, hssfCell.getCellType()); // Important: Preserve original type if possible

                 // Copy Cell Value (Handles Formulas and Cached Values)
                 copyCellValue(hssfCell, xssfCell);

                 // Copy Cell Style (Uses Caching, Handles Colors Correctly)
                 HSSFCellStyle hssfStyle = hssfCell.getCellStyle();
                 if (hssfStyle != null) {
                      XSSFCellStyle xssfStyle = getOrCreateXSSFStyle(hssfStyle, hssfWorkbook, xssfWorkbook, hssfPalette);
                      if (xssfStyle != null) {
                         xssfCell.setCellStyle(xssfStyle);
                      }
                 }

                 // Copy Cell Comment
                 HSSFComment hssfComment = hssfCell.getCellComment();
                 if (hssfComment != null) {
                      copyCellComment(hssfComment, xssfCell);
                 }

                 // Copy Hyperlink
                 HSSFHyperlink hssfLink = hssfCell.getHyperlink();
                 if (hssfLink != null) {
                     copyHyperlink(hssfLink, xssfCell);
                 }

                 maxColNum = Math.max(maxColNum, colIndex + 1);
            }
        }
        log.debug("Finished copying rows/cells for sheet '{}'. Max columns used: {}", xssfSheet.getSheetName(), maxColNum);
    }

    // --- Copy Row Properties ---
    private void copyRowProperties(HSSFRow hssfRow, XSSFRow xssfRow) {
        xssfRow.setHeightInPoints(hssfRow.getHeightInPoints());
        if (hssfRow.getZeroHeight()) {
            xssfRow.setZeroHeight(true);
        }
        // Copy row style if necessary (less common)
        // HSSFCellStyle hssfRowStyle = hssfRow.getRowStyle();
        // if (hssfRowStyle != null) { ... copy style ... }
    }


    // --- Cell Value Copying (Handles Formulas and Fallbacks) ---
    private void copyCellValue(HSSFCell hssfCell, XSSFCell xssfCell) {
        CellType cellType = hssfCell.getCellType();

        if (cellType == CellType.FORMULA) {
            String formula = hssfCell.getCellFormula();
            try {
                xssfCell.setCellFormula(formula);
            } catch (FormulaParseException | RecordFormatException fpe) {
                log.warn("Could not copy formula '{}' from HSSF[{},{}] to XSSF. Attempting to copy cached value. Error: {}",
                         formula, hssfCell.getRowIndex(), hssfCell.getColumnIndex(), fpe.getMessage());
                copyCachedFormulaValue(hssfCell, xssfCell);
            } catch (Exception e) {
                log.error("Unexpected error setting formula '{}' at XSSF[{},{}].",
                          formula, xssfCell.getRowIndex(), xssfCell.getColumnIndex(), e);
                xssfCell.setBlank(); // Fallback to blank on unexpected error
            }
        } else {
            // Handle non-formula types directly
            switch (cellType) {
                case STRING:
                    xssfCell.setCellValue(hssfCell.getStringCellValue());
                    break;
                case NUMERIC:
                    copyNumericCellValue(hssfCell, xssfCell);
                    break;
                case BOOLEAN:
                    xssfCell.setCellValue(hssfCell.getBooleanCellValue());
                    break;
                case BLANK:
                    xssfCell.setBlank();
                    break;
                case ERROR:
                    xssfCell.setCellErrorValue(hssfCell.getErrorCellValue());
                    break;
                default:
                    log.warn("Unhandled HSSF cell type '{}' at [{},{}]. Setting target cell to blank.",
                             cellType, hssfCell.getRowIndex(), hssfCell.getColumnIndex());
                    xssfCell.setBlank();
            }
        }
    }

    private void copyNumericCellValue(HSSFCell hssfCell, XSSFCell xssfCell) {
        double numericValue = hssfCell.getNumericCellValue();
        if (DateUtil.isCellDateFormatted(hssfCell)) {
            try {
                xssfCell.setCellValue(hssfCell.getDateCellValue());
                 // Important: Ensure the XSSF cell also gets a date format style!
                 // The style copying logic should handle this via DataFormat.
            } catch (Exception e) {
                log.warn("Could not format numeric value {} as date at HSSF[{},{}]. Copying as number. Error: {}",
                         numericValue, hssfCell.getRowIndex(), hssfCell.getColumnIndex(), e.getMessage());
                xssfCell.setCellValue(numericValue);
            }
        } else {
            xssfCell.setCellValue(numericValue);
        }
    }

    private void copyCachedFormulaValue(HSSFCell hssfCell, XSSFCell xssfCell) {
         try {
            CellType cachedType = hssfCell.getCachedFormulaResultType();
            log.debug("Copying cached formula value of type {} for HSSF[{},{}]",
                     cachedType, hssfCell.getRowIndex(), hssfCell.getColumnIndex());
            switch (cachedType) {
                case STRING:
                    xssfCell.setCellValue(hssfCell.getStringCellValue());
                    break;
                case NUMERIC:
                    copyNumericCellValue(hssfCell, xssfCell); // Reuse numeric/date handling
                     break;
                case BOOLEAN:
                    xssfCell.setCellValue(hssfCell.getBooleanCellValue());
                    break;
                case ERROR:
                    xssfCell.setCellErrorValue(hssfCell.getErrorCellValue());
                    break;
                case BLANK:
                default:
                    xssfCell.setBlank();
                    break;
            }
         } catch (Exception e) {
              log.error("Error retrieving cached formula value for HSSF[{},{}]. Setting blank.",
                      hssfCell.getRowIndex(), hssfCell.getColumnIndex(), e);
             xssfCell.setBlank(); // Safe fallback
         }
    }


    // --- Cell Style Copying (with Caching and CORRECT Color Handling) ---
    private XSSFCellStyle getOrCreateXSSFStyle(HSSFCellStyle hssfStyle, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook, HSSFPalette hssfPalette) {
        int hssfStyleIndex = hssfStyle.getIndex(); // Use index as cache key

        if (styleMap.containsKey(hssfStyleIndex)) {
            return styleMap.get(hssfStyleIndex);
        }

        XSSFCellStyle xssfStyle = xssfWorkbook.createCellStyle();
        try {
            // Alignment
            xssfStyle.setAlignment(hssfStyle.getAlignment());
            xssfStyle.setVerticalAlignment(hssfStyle.getVerticalAlignment());

            // Borders (Style)
            xssfStyle.setBorderBottom(hssfStyle.getBorderBottom());
            xssfStyle.setBorderLeft(hssfStyle.getBorderLeft());
            xssfStyle.setBorderRight(hssfStyle.getBorderRight());
            xssfStyle.setBorderTop(hssfStyle.getBorderTop());

            // --- CORRECTED Border Colors ---
            // 1. Get color INDEX (short)
            // 2. Resolve index to HSSFColor using palette
            // 3. Convert HSSFColor to XSSFColor
            HSSFColor bottomBorderHSSFColor = hssfPalette.getColor(hssfStyle.getBottomBorderColor());
            xssfStyle.setBottomBorderColor(convertToXSSFColor(bottomBorderHSSFColor, hssfPalette));

            HSSFColor leftBorderHSSFColor = hssfPalette.getColor(hssfStyle.getLeftBorderColor());
            xssfStyle.setLeftBorderColor(convertToXSSFColor(leftBorderHSSFColor, hssfPalette));

            HSSFColor rightBorderHSSFColor = hssfPalette.getColor(hssfStyle.getRightBorderColor());
            xssfStyle.setRightBorderColor(convertToXSSFColor(rightBorderHSSFColor, hssfPalette));

            HSSFColor topBorderHSSFColor = hssfPalette.getColor(hssfStyle.getTopBorderColor());
            xssfStyle.setTopBorderColor(convertToXSSFColor(topBorderHSSFColor, hssfPalette));

            // Fill Pattern
            xssfStyle.setFillPattern(hssfStyle.getFillPattern());

            // --- CORRECTED Fill Colors ---
            HSSFColor fillForegroundHSSFColor = hssfPalette.getColor(hssfStyle.getFillForegroundColor());
            if (fillForegroundHSSFColor != null) { // Check if color exists
                 xssfStyle.setFillForegroundColor(convertToXSSFColor(fillForegroundHSSFColor, hssfPalette));
            }

            HSSFColor fillBackgroundHSSFColor = hssfPalette.getColor(hssfStyle.getFillBackgroundColor());
             if (fillBackgroundHSSFColor != null) {
                 xssfStyle.setFillBackgroundColor(convertToXSSFColor(fillBackgroundHSSFColor, hssfPalette));
             }

            // Font
            HSSFFont hssfFont = hssfStyle.getFont(hssfWorkbook);
            if (hssfFont != null) {
                XSSFFont xssfFont = getOrCreateXSSFFont(hssfFont, hssfWorkbook, xssfWorkbook, hssfPalette);
                if (xssfFont != null) {
                    xssfStyle.setFont(xssfFont);
                }
            }

            // Data Format
             copyDataFormat(hssfStyle, xssfStyle, xssfWorkbook);

            // Other properties
            xssfStyle.setHidden(hssfStyle.getHidden());
            xssfStyle.setLocked(hssfStyle.getLocked());
            xssfStyle.setWrapText(hssfStyle.getWrapText());
            xssfStyle.setIndention(hssfStyle.getIndention());
            xssfStyle.setRotation(hssfStyle.getRotation());
            // xssfStyle.setShrinkToFit(...) // No direct equivalent get method in HSSFCellStyle

            // Cache the created style
            styleMap.put(hssfStyleIndex, xssfStyle);
            return xssfStyle;

        } catch (Exception e) {
            log.error("Failed to copy HSSFCellStyle index {} to XSSFCellStyle. Error: {}", hssfStyleIndex, e.getMessage(), e);
            return null; // Return null on failure to avoid breaking entire process
        }
    }

     // --- Data Format Copying ---
     private void copyDataFormat(HSSFCellStyle hssfStyle, XSSFCellStyle xssfStyle, XSSFWorkbook xssfWorkbook) {
         try {
             short hssfDataFormatIndex = hssfStyle.getDataFormat();
             String hssfDataFormatString = hssfStyle.getDataFormatString();
             // Builtin formats might return "General" etc. but have specific indices.
             // Using the format string is generally preferred for custom formats.
             // If the string is generic like "General", maybe trust the index? Needs testing.
             if (hssfDataFormatString != null && !hssfDataFormatString.equalsIgnoreCase("General")) {
                 XSSFDataFormat xssfDataFormat = xssfWorkbook.createDataFormat();
                 xssfStyle.setDataFormat(xssfDataFormat.getFormat(hssfDataFormatString));
             } else {
                  // If format string is generic or null, try using the index directly.
                 // This might map built-in formats correctly.
                 xssfStyle.setDataFormat(hssfDataFormatIndex);
                 log.trace("Using HSSF data format index {} directly for XSSF style.", hssfDataFormatIndex);
             }
         } catch (Exception e) {
             log.warn("Could not copy data format for HSSF style index {}. Error: {}", hssfStyle.getIndex(), e.getMessage());
             // Optionally set a default format like General (index 0)
             // xssfStyle.setDataFormat((short) 0);
         }
     }


     // --- Font Copying (with Caching and CORRECT Color Handling) ---
    private XSSFFont getOrCreateXSSFFont(HSSFFont hssfFont, HSSFWorkbook hssfWorkbook, XSSFWorkbook xssfWorkbook, HSSFPalette hssfPalette) {
        short hssfFontIndex = hssfFont.getIndexAsInt(); // Use index as cache key

        if (fontMap.containsKey(hssfFontIndex)) {
            return fontMap.get(hssfFontIndex);
        }

        XSSFFont xssfFont = xssfWorkbook.createFont();
        try {
            xssfFont.setFontName(hssfFont.getFontName());
            xssfFont.setFontHeightInPoints(hssfFont.getFontHeightInPoints());
            xssfFont.setBold(hssfFont.getBold());
            xssfFont.setItalic(hssfFont.getItalic());
            xssfFont.setStrikeout(hssfFont.getStrikeout());
            xssfFont.setUnderline(hssfFont.getUnderline());
            xssfFont.setTypeOffset(hssfFont.getTypeOffset()); // Super/subscript

            // --- CORRECTED Font Color ---
            // HSSFFont provides a helper to get the HSSFColor directly using workbook context
            HSSFColor hssfColor = hssfFont.getHSSFColor(hssfWorkbook); // This handles palette lookup internally
            if (hssfColor != null) {
                 xssfFont.setColor(convertToXSSFColor(hssfColor, hssfPalette));
            } // If hssfColor is null, it's likely 'automatic', leave xssfFont color as default

            // Charset (often ignored or problematic in XSSF)
            // xssfFont.setCharSet(hssfFont.getCharSet());

             fontMap.put(hssfFontIndex, xssfFont); // Cache the font
            return xssfFont;
        } catch (Exception e) {
             log.error("Failed to copy HSSFFont index {} to XSSFFont. Error: {}", hssfFontIndex, e.getMessage(), e);
             return null; // Return null on failure
        }
    }

    // --- Color Conversion Utility (Handles Palette, Predefined, Automatic) ---
    private XSSFColor convertToXSSFColor(HSSFColor hssfColor, HSSFPalette hssfPalette) {
        if (hssfColor == null) {
            return null; // Treat null HSSFColor input as automatic/default
        }

        // Check for Automatic color index FIRST
        if (hssfColor.getIndex() == HSSFColor.HSSFColorPredefined.AUTOMATIC.getIndex()) {
            return null; // Return null to let XSSF handle automatic color based on context
        }

        // Get RGB triplet directly from the HSSFColor object.
        // HSSFColor objects obtained from the palette or predefined list contain the RGB info.
        short[] tripletShort = hssfColor.getTriplet();
        if (tripletShort == null) {
             log.warn("HSSFColor index {} provided null RGB triplet. Cannot convert.", hssfColor.getIndex());
             return null;
        }

        // Explicit cast short -> byte for RGB. This is intentional for 0-255 range.
        byte[] rgbBytes = new byte[] { (byte) tripletShort[0], (byte) tripletShort[1], (byte) tripletShort[2] };

        try {
            // Create XSSFColor using the RGB bytes. Second arg (color map) is usually null for custom RGB.
            return new XSSFColor(rgbBytes, null);
        } catch (Exception e) {
            log.warn("Failed to create XSSFColor from RGB ({},{},{}) derived from HSSF index {}. Error: {}",
                     rgbBytes[0], rgbBytes[1], rgbBytes[2], hssfColor.getIndex(), e.getMessage());
            return null; // Fallback if creation fails
        }
    }


    // --- Merged Regions Copying ---
    private void copyMergedRegions(HSSFSheet hssfSheet, XSSFSheet xssfSheet) {
        int numMergedRegions = hssfSheet.getNumMergedRegions();
        if (numMergedRegions == 0) return;

        log.debug("Copying {} merged regions for sheet '{}'", numMergedRegions, xssfSheet.getSheetName());
        for (int i = 0; i < numMergedRegions; i++) {
            CellRangeAddress mergedRegion = null;
            try {
                 mergedRegion = hssfSheet.getMergedRegion(i); // Can throw exception on invalid region data
                 if (mergedRegion != null) {
                    xssfSheet.addMergedRegion(mergedRegion);
                 } else {
                     log.warn("HSSFSheet.getMergedRegion({}) returned null on sheet '{}'. Skipping.", i, hssfSheet.getSheetName());
                 }
            } catch (IllegalArgumentException | RecordFormatException e) {
                String regionStr = (mergedRegion != null) ? mergedRegion.formatAsString() : "index " + i;
                log.warn("Could not add merged region {} to sheet '{}'. It might overlap, be invalid, or file is corrupt. Skipping. Error: {}",
                    regionStr, xssfSheet.getSheetName(), e.getMessage());
            } catch (Exception e) {
                 String regionStr = (mergedRegion != null) ? mergedRegion.formatAsString() : "index " + i;
                 log.error("Unexpected error processing merged region {} on sheet '{}'. Skipping.",
                    regionStr, xssfSheet.getSheetName(), e);
            }
        }
    }

    // --- Column Width and Hidden Status Copying ---
    private void copyColumnWidths(HSSFSheet hssfSheet, XSSFSheet xssfSheet) {
        // Determine max column based on actual cell usage (more reliable than relying on explicit width settings)
        int maxCol = 0;
        for (Row row : hssfSheet) {
            if (row != null && row.getLastCellNum() >= 0) {
                 maxCol = Math.max(maxCol, row.getLastCellNum());
            }
        }
        log.debug("Max column index determined as {} for width copying on sheet '{}'", maxCol, xssfSheet.getSheetName());

        // Copy individual column widths AND hidden status
        for (int colNum = 0; colNum < maxCol; colNum++) {
             // Copy width if it's explicitly set and different from default
            int width = hssfSheet.getColumnWidth(colNum);
            int defaultCharWidth = hssfSheet.getDefaultColumnWidth(); // Width in characters
            int defaultWidthUnits = defaultCharWidth * 256; // Width in POI units

            // Only set width if it's different from default AND valid (>0 or =0 for hidden)
            if (width != defaultWidthUnits && width >= 0) {
                 int clampedWidth = Math.min(width, 65280); // Clamp to Excel max (255 chars * 256)
                 if (width > 65280) {
                     log.warn("HSSF column {} width {} exceeds XLSX maximum (65280). Clamping.", colNum, width);
                 }
                 xssfSheet.setColumnWidth(colNum, clampedWidth);
            }

            // Copy hidden status separately (width=0 implies hidden, but this is explicit)
            if (hssfSheet.isColumnHidden(colNum)) {
                xssfSheet.setColumnHidden(colNum, true);
            }
        }

        // Copy default column width for the sheet
        xssfSheet.setDefaultColumnWidth(hssfSheet.getDefaultColumnWidth());
        log.debug("Copied column widths/hidden status and default width for sheet '{}'", xssfSheet.getSheetName());
    }


    // --- Cell Comment Copying ---
    private void copyCellComment(HSSFComment hssfComment, XSSFCell xssfCell) {
        if (hssfComment == null || xssfCell == null) return;

        XSSFSheet xssfSheet = xssfCell.getSheet();
        // Use existing drawing patriarch or create a new one
        XSSFDrawing drawing = xssfSheet.getDrawingPatriarch();
        if (drawing == null) {
            drawing = xssfSheet.createDrawingPatriarch();
        }

        ClientAnchor anchor = hssfComment.getAnchor();
        XSSFClientAnchor xssfAnchor = null;

        // Check if the anchor is the expected HSSF type and create XSSF equivalent
        if (anchor instanceof HSSFClientAnchor) { // Check before cast
            HSSFClientAnchor hssfAnchor = (HSSFClientAnchor) anchor;
             xssfAnchor = drawing.createAnchor(
                    hssfAnchor.getDx1(), hssfAnchor.getDy1(), hssfAnchor.getDx2(), hssfAnchor.getDy2(),
                    hssfAnchor.getCol1(), hssfAnchor.getRow1(), hssfAnchor.getCol2(), hssfAnchor.getRow2());
        } else {
            // Log if anchor type is unexpected and create a default fallback anchor
            log.warn("Comment anchor at HSSF[{},{}] was not HSSFClientAnchor (type: {}). Using default position.",
                     xssfCell.getRowIndex(), xssfCell.getColumnIndex(), anchor != null ? anchor.getClass().getName() : "null");
            xssfAnchor = drawing.createAnchor(0, 0, 0, 0, // Default offsets
                     xssfCell.getColumnIndex(), xssfCell.getRowIndex(), // Anchor to cell
                     xssfCell.getColumnIndex() + 2, xssfCell.getRowIndex() + 3); // Default size (2x3 cells approx)
        }

        XSSFComment xssfComment = drawing.createCellComment(xssfAnchor);

        // Copy text (attempt rich text copy, fallback to plain)
        RichTextString hssfRichText = hssfComment.getString();
        if (hssfRichText != null) {
            if (hssfRichText instanceof HSSFRichTextString) {
                // NOTE: Full rich text font copying is complex due to context needs.
                // This simplified version copies text but likely loses font formatting within the comment.
                 xssfComment.setString(new XSSFRichTextString(hssfRichText.getString()));
                 log.trace("Copied comment text for HSSF[{},{}]. Rich text formatting may be lost.",
                         xssfCell.getRowIndex(), xssfCell.getColumnIndex());
                 // copyRichTextString((HSSFRichTextString) hssfRichText, xssfCell.getSheet().getWorkbook()); // Call complex version if needed
            } else {
                xssfComment.setString(new XSSFRichTextString(hssfRichText.getString())); // Copy as plain string
            }
        } else {
            xssfComment.setString(new XSSFRichTextString("")); // Ensure non-null string
        }

        // Copy author and visibility
        try {
            xssfComment.setAuthor(hssfComment.getAuthor());
        } catch (Exception e) { /* Ignore or log */ }
        xssfComment.setVisible(hssfComment.isVisible());

        xssfCell.setCellComment(xssfComment); // Assign comment to cell
    }


    // --- Hyperlink Copying ---
    private void copyHyperlink(HSSFHyperlink hssfLink, XSSFCell xssfCell) {
        if (hssfLink == null || xssfCell == null) return;

        XSSFWorkbook xssfWorkbook = xssfCell.getSheet().getWorkbook();
        XSSFCreationHelper helper = xssfWorkbook.getCreationHelper();

        try {
            // Use common HyperlinkType enum
             HyperlinkType linkType;
             switch (hssfLink.getType()) {
                case URL:       linkType = HyperlinkType.URL;      break;
                case FILE:      linkType = HyperlinkType.FILE;     break;
                case EMAIL:     linkType = HyperlinkType.EMAIL;    break;
                case DOCUMENT:  linkType = HyperlinkType.DOCUMENT; break;
                default:
                     log.warn("Unsupported HSSFHyperlink type '{}' at HSSF[{},{}]. Skipping.",
                             hssfLink.getTypeEnum(), xssfCell.getRowIndex(), xssfCell.getColumnIndex());
                     return;
             }

            XSSFHyperlink xssfLink = helper.createHyperlink(linkType);
            xssfLink.setAddress(hssfLink.getAddress()); // Address/target is key

            // Set cell range (usually just the single cell)
            CellRangeAddress address = new CellRangeAddress(
                    xssfCell.getRowIndex(), xssfCell.getRowIndex(),
                    xssfCell.getColumnIndex(), xssfCell.getColumnIndex());
            xssfLink.setCellReference(address.formatAsString());

            // Copy label if present
            if (hssfLink.getLabel() != null) {
                xssfLink.setLabel(hssfLink.getLabel());
            }

            xssfCell.setHyperlink(xssfLink); // Assign link to cell

            // Apply default hyperlink style if none exists or if it's basic
            applyDefaultHyperlinkStyleIfNeeded(xssfCell, xssfWorkbook);

        } catch (Exception e) {
            log.error("Failed to copy hyperlink from HSSF[{},{}] address='{}'. Error: {}",
                    xssfCell.getRowIndex(), xssfCell.getColumnIndex(), hssfLink.getAddress(), e.getMessage(), e);
        }
    }

    // --- Hyperlink Style Helper ---
    private void applyDefaultHyperlinkStyleIfNeeded(XSSFCell cell, XSSFWorkbook workbook) {
         CellStyle currentStyle = cell.getCellStyle();
         boolean needsDefaultStyle = false;

         if (currentStyle == null) {
             needsDefaultStyle = true;
         } else {
             Font currentFont = workbook.getFontAt(currentStyle.getFontIndex());
             // Check if font is missing standard hyperlink features (blue color, underline)
             // Note: This is a simplified check. Real hyperlink styles might vary.
             if (currentFont.getUnderline() == Font.U_NONE || currentFont.getColor() != IndexedColors.BLUE.getIndex()) {
                 needsDefaultStyle = true;
             }
         }

         if (needsDefaultStyle) {
             if (this.defaultHyperlinkStyle == null) {
                 // Create and cache the default style if not already done
                 this.defaultHyperlinkStyle = createDefaultHyperlinkStyle(workbook);
             }
             if (this.defaultHyperlinkStyle != null) {
                 cell.setCellStyle(this.defaultHyperlinkStyle);
             }
         }
    }

    // Creates the default hyperlink style (blue, underlined)
    private XSSFCellStyle createDefaultHyperlinkStyle(XSSFWorkbook workbook) {
        try {
            XSSFCellStyle style = workbook.createCellStyle();
            XSSFFont font = workbook.createFont();
            font.setUnderline(Font.U_SINGLE);
            // Use standard blue color index
            font.setColor(IndexedColors.BLUE.getIndex());
            style.setFont(font);
            return style;
        } catch (Exception e) {
            log.error("Failed to create default hyperlink style. Links may not appear styled.", e);
            return null;
        }
    }

    // --- Rich Text Copying (Advanced - Requires Context - Usually Simplified for Comments) ---
    // This is the complex version that attempts font copying. Called ONLY if full fidelity is needed.
    /*
    private XSSFRichTextString copyRichTextString(HSSFRichTextString hssfRichText, XSSFWorkbook xssfWorkbook, HSSFWorkbook sourceHssfWorkbook, HSSFPalette sourcePalette) {
        // ... [Implementation similar to previous attempts, requiring source workbook/palette context] ...
        // ... [Needs careful handling of indices and font mapping] ...
         log.warn("Full rich text formatting copy is complex and context-dependent.");
         // Fallback to simple text copy if full implementation is too difficult/error-prone
         return new XSSFRichTextString(hssfRichText.getString());
    }
    */

}
```

**关键修正和改进：**

1.  **移除了`*ColorColor`错误方法:** 所有获取颜色的地方（边框、填充、字体）现在都使用正确的方法获取颜色索引（`short`类型），例如 `hssfStyle.getBottomBorderColor()`。
2.  **正确的颜色解析:** 获取到索引后，使用 `HSSFPalette.getColor(short index)` 来查找对应的 `HSSFColor` 对象。
3.  **正确的颜色转换:** `convertToXSSFColor` 方法现在接收 `HSSFColor` 对象作为输入，并正确处理来自调色板、预定义颜色或 `null`（表示自动）的情况。
4.  **字体颜色修正:** 使用 `hssfFont.getHSSFColor(hssfWorkbook)` 来获取字体的 `HSSFColor` 对象，这个方法内部处理了调色板查找。
5.  **公式处理:** 保留了之前的改进，优先尝试复制公式本身，如果失败（例如公式在XLSX中无效），则尝试复制缓存的结果值。
6.  **批注锚点:** 保留了 `instanceof HSSFClientAnchor` 的检查，确保在类型转换前进行验证，并提供了一个备用的默认锚点。
7.  **超链接复制:** 添加了超链接复制逻辑，并尝试在单元格没有特定样式或缺少链接特征（如下划线、蓝色）时应用默认的超链接样式（蓝色、下划线）。创建并缓存了默认超链接样式以提高效率。
8.  **富文本 (Rich Text):** 批注中的富文本复制仍然被简化为只复制文本内容，因为精确复制字体格式需要复杂的上下文传递（源 HSSFWorkbook）。如果需要完整的富文本格式保留，需要更复杂的实现（如 `copyRichTextString` 的完整版本，但未在此代码中完全实现）。
9.  **代码结构和健壮性:** 增加了更多的 `try-catch` 块和日志记录，特别是在处理可能失败的操作（如合并区域、样式复制）时返回 `null` 或跳过，以避免整个转换过程因单个错误而中断。
10. **依赖:** 确保 `pom.xml` 中包含正确的 Apache POI 依赖 (`poi` 和 `poi-ooxml` 及其相关依赖)。

这个版本应该能更准确地处理颜色和其他样式属性。请再次测试它，特别是包含复杂颜色、边框、填充和字体样式的 `.xls` 文件。