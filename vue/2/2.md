Okay, understanding that the backslashes and spaces are part of an intentional escaping mechanism from the frontend is key. We need to make the `cleanAndDecodeStyleAttribute` function specifically undo this escaping *before* parsing the CSS declarations.

The strategy will be:

1.  Remove any outer wrappers (like surrounding `&quot;` or `"`).
2.  Unescape core HTML entities (`&amp;`, `&lt;` etc.).
3.  Explicitly replace the frontend's escape sequences (like `\:`, `\;`, `\"`, `\ `) with their literal counterparts (`:`, `;`, `"`, ` ` or empty string depending on intent).
4.  Normalize whitespace around the now-literal separators.
5.  Trim any remaining garbage like trailing separators.

Let's rewrite the `cleanAndDecodeStyleAttribute` helper within the full service class.

**Complete `ExcelConversionService.java` with Enhanced Cleaning:**

```java
package com.example.htmltoxlsx.service; // Adjust package name as needed

// Core Spring and Logging imports
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

// Apache POI (XSSF for .xlsx output) imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.DefaultIndexedColorMap;
import org.apache.poi.xssf.usermodel.extensions.XSSFCellBorder.BorderSide;
import org.apache.poi.ss.util.WorkbookUtil; // For safe sheet names

// Jsoup (HTML Parsing) imports
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.parser.Parser; // Import Jsoup Parser for unescaping

// Java IO and Util imports
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.awt.Color;

// Commons IO / Lang imports
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.lang3.StringUtils;


@Service
@Slf4j
public class ExcelConversionService {

    // --- Caches for Performance ---
    private final Map<String, XSSFCellStyle> htmlStyleCache = new HashMap<>();
    private final Map<String, XSSFFont> htmlFontCache = new HashMap<>();

    // --- Limits ---
    private static final int MAX_SUPPORTED_ROWS = 100000;
    private static final int MAX_SUPPORTED_COLS = 200;

    // --- Main Conversion Method: HTML Table String -> XLSX ---
    public byte[] convertOuterHtmlTableToXlsx(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Input file is empty or null.");
        }
        String originalFilename = file.getOriginalFilename();
        log.info("Attempting conversion of HTML table from file ({}) to XLSX format.", originalFilename);
        htmlStyleCache.clear(); htmlFontCache.clear();

        try (InputStream inputStream = file.getInputStream();
             XSSFWorkbook workbook = new XSSFWorkbook();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            String htmlContent = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
            if (StringUtils.isBlank(htmlContent)) {
                 throw new IllegalArgumentException("Input file contains no processable content.");
            }

            Document doc = Jsoup.parseBodyFragment(htmlContent);
            log.debug("Parsed input stream as HTML body fragment.");

            Element table = doc.body().selectFirst("table");
            if (table == null) {
                throw new IllegalArgumentException("The provided content does not contain a valid HTML table structure.");
            }
            log.debug("Found the first HTML table element to process.");

            String sheetName = "Sheet1";
            XSSFSheet sheet = workbook.createSheet(sheetName);
            log.debug("Processing HTML table into sheet '{}'", sheetName);

            processHtmlTableToSheet(table, sheet, workbook);

            workbook.write(baos);
            log.info("Successfully converted HTML table from {} to XLSX format (Sheet: '{}').", originalFilename, sheetName);
            return baos.toByteArray();

        } catch (IOException ioe) { log.error("IO Error during HTML to XLSX conversion for file: {}", originalFilename, ioe); throw ioe; }
        catch (OutOfMemoryError oom) { log.error("OutOfMemoryError during conversion for file: {}. Input HTML might be too large.", originalFilename, oom); throw new IOException("Conversion failed due to excessive memory usage. The input HTML may be too large.", oom); }
        catch (Exception e) { log.error("Unexpected error during HTML to XLSX conversion for file: {}", originalFilename, e); throw new IOException("Conversion failed unexpectedly: " + e.getMessage(), e); }
        finally { htmlStyleCache.clear(); htmlFontCache.clear(); }
    }

    // --- Processes a single HTML table element into an XSSFSheet ---
    private void processHtmlTableToSheet(Element table, XSSFSheet sheet, XSSFWorkbook workbook) {
         Elements rows = table.select("tr");
         int rowIndex = 0;
         boolean[][] cellOccupied = new boolean[Math.min(rows.size(), MAX_SUPPORTED_ROWS) + 5][MAX_SUPPORTED_COLS + 5];
         Map<Integer, Integer> columnMaxChars = new HashMap<>();

         for (Element row : rows) {
              if (rowIndex >= MAX_SUPPORTED_ROWS) break;
             XSSFRow xssfRow = sheet.createRow(rowIndex);
             Elements cells = row.select("th, td");
             int currentCellIndex = 0;

             for (Element cell : cells) {
                  while (currentCellIndex < MAX_SUPPORTED_COLS && cellOccupied[rowIndex][currentCellIndex]) currentCellIndex++;
                  if (currentCellIndex >= MAX_SUPPORTED_COLS) break;

                 XSSFCell xssfCell = xssfRow.createCell(currentCellIndex);
                 String cellText = cell.text();
                 setCellValue(xssfCell, cellText);
                 updateMaxChars(columnMaxChars, currentCellIndex, cellText);

                 // *** Call the MODIFIED style creation method ***
                 XSSFCellStyle xssfStyle = createAndCacheStyleFromHtml(cell, workbook);
                 if (xssfStyle != null) xssfCell.setCellStyle(xssfStyle);

                 int colspan = NumberUtils.toInt(cell.attr("colspan"), 1);
                 int rowspan = NumberUtils.toInt(cell.attr("rowspan"), 1);
                 rowspan = Math.min(rowspan, MAX_SUPPORTED_ROWS - rowIndex);
                 colspan = Math.min(colspan, MAX_SUPPORTED_COLS - currentCellIndex);
                 handleMergedRegions(sheet, cellOccupied, rowIndex, currentCellIndex, rowspan, colspan);

                 currentCellIndex += colspan;
             }
             rowIndex++;
         }
         applyColumnWidths(sheet, columnMaxChars);
    }


    // --- Helper: Create/Cache XSSFCellStyle from HTML inline style attribute ---
    // Handles encoded styles and prioritizes spans
    private XSSFCellStyle createAndCacheStyleFromHtml(Element cell, XSSFWorkbook workbook) {
        String rawStyleAttr = null;
        boolean styleFromSpan = false;

        // 1. Prioritize style from first span inside cell
        Element firstSpan = cell.selectFirst("span");
        if (firstSpan != null) {
            String spanStyle = firstSpan.attr("style");
            if (StringUtils.isNotBlank(spanStyle)) {
                rawStyleAttr = spanStyle;
                styleFromSpan = true;
                // log.trace("Using style from inner span."); // Optional log
            }
        }

        // 2. Fallback to cell's style attribute
        if (rawStyleAttr == null) {
            rawStyleAttr = cell.attr("style");
        }

        // 3. No style found
        if (StringUtils.isBlank(rawStyleAttr)) {
            return null;
        }

        // 4. *** Clean and Decode the Raw Style String (Handling Backslash Escapes) ***
        String cleanedStyleAttr = cleanAndDecodeStyleAttribute(rawStyleAttr);
        if (StringUtils.isBlank(cleanedStyleAttr)) {
             log.trace("Style attribute was blank after cleaning/decoding: Raw='{}'", rawStyleAttr);
            return null;
        }
        log.trace("Cleaned style string for parsing: '{}'", cleanedStyleAttr); // Log cleaned string

        // 5. --- Caching based on the *cleaned* style string ---
        if (htmlStyleCache.containsKey(cleanedStyleAttr)) {
            return htmlStyleCache.get(cleanedStyleAttr);
        }

        // 6. --- Style Creation & Parsing (using cleanedStyleAttr) ---
        XSSFCellStyle style = workbook.createCellStyle();
        XSSFFont baseFont = workbook.getFontAt((short) 0);
        XSSFFont currentFont = baseFont;
        boolean fontNeedsCloning = true;
        boolean fontIsModified = false;
        boolean styleIsModified = false;

        style.setWrapText(false); // Start with Excel default (no wrap)

        // --- Parse CSS Declarations from the cleaned string ---
        String[] declarations = cleanedStyleAttr.split(";"); // Split by SEMICOLON
        for (String declaration : declarations) {
             if (StringUtils.isBlank(declaration)) continue;
             // Split by COLON for property/value
             String[] parts = declaration.split(":", 2);
             if (parts.length != 2) {
                 log.warn("Skipping invalid CSS declaration part: '{}'", declaration);
                 continue;
             }
             String property = parts[0].trim().toLowerCase();
             String value = parts[1].trim().toLowerCase(); // Keep value lower for matching, unless case matters (e.g., font names?)

            try {
                if (fontNeedsCloning && isFontProperty(property)) {
                    XSSFFont clonedFont = workbook.createFont();
                    clonedFont.cloneStyleFrom(baseFont);
                    currentFont = clonedFont;
                    fontNeedsCloning = false;
                    fontIsModified = true;
                }
                boolean applied = applyCssProperty(property, value, style, currentFont);
                if (applied) styleIsModified = true;
            } catch (Exception e) {
                 log.warn("Could not parse/apply style property: '{}' with value '{}'. Error: {}", property, value, e.getMessage());
            }
        }

        // --- Final Font Handling ---
        if (fontIsModified) {
            String fontKey = generateFontKey(currentFont);
            XSSFFont finalFont = htmlFontCache.computeIfAbsent(fontKey, k -> currentFont);
            style.setFont(finalFont);
            styleIsModified = true;
        }

        // --- Cache and Return ---
        if (styleIsModified) {
            htmlStyleCache.put(cleanedStyleAttr, style); // Cache using cleaned string as key
            return style;
        } else {
            return null;
        }
    }

    // --- *** UPDATED Helper function to clean and decode style attribute *** ---
    // Handles surrounding quotes (&quot; or "), HTML entities, and backslash escapes (\:, \;, \", \ )
    private String cleanAndDecodeStyleAttribute(String rawStyle) {
        if (rawStyle == null) return null;

        // 1. Trim initial whitespace
        String cleaned = rawStyle.trim();
        // log.trace("Raw style input: '{}'", cleaned); // Keep logging for debugging if needed

        // 2. Remove surrounding &quot; or "
        if (cleaned.startsWith("&quot;") && cleaned.endsWith("&quot;")) {
            cleaned = (cleaned.length() >= 12) ? cleaned.substring(6, cleaned.length() - 6) : "";
        } else if (cleaned.startsWith("\"") && cleaned.endsWith("\"")) {
             cleaned = (cleaned.length() >= 2) ? cleaned.substring(1, cleaned.length() - 1) : "";
        }
        // log.trace("After removing outer quotes: '{}'", cleaned);

        // 3. Unescape core HTML entities first (e.g., &amp; -> &)
        if (cleaned.contains("&")) {
            cleaned = Parser.unescapeEntities(cleaned, false);
            // log.trace("After unescaping HTML entities: '{}'", cleaned);
        }

        // 4. **** Handle specific backslash escapes used by frontend ****
        // Order can matter. Replace escaped spaces first if they are just separators.
        if (cleaned.contains("\\ ")) { // Backslash followed by space
            cleaned = cleaned.replace("\\ ", ""); // Remove entirely, assume they pad separators
             // log.trace("After removing escaped spaces: '{}'", cleaned);
        }
        if (cleaned.contains("\\:")) { // Backslash colon
            cleaned = cleaned.replace("\\:", ":");
             // log.trace("After replacing escaped colons: '{}'", cleaned);
        }
        if (cleaned.contains("\\;")) { // Backslash semicolon
            cleaned = cleaned.replace("\\;", ";");
             // log.trace("After replacing escaped semicolons: '{}'", cleaned);
        }
         if (cleaned.contains("\\\"")) { // Backslash quote
             cleaned = cleaned.replace("\\\"", "\"");
             // log.trace("After replacing escaped inner quotes: '{}'", cleaned);
         }
         // Optional: Handle double backslashes if escaping is more complex (e.g., \\ -> \)
         // if (cleaned.contains("\\\\")) {
         //     cleaned = cleaned.replace("\\\\", "\\");
         // }

        // 5. Normalize whitespace around separators (make it 'property:value;')
        // Ensure there's no space before colon, one space after; ensure space after semicolon (or end)
        cleaned = cleaned.replaceAll("\\s*:\\s*", ":"); // property:value
        cleaned = cleaned.replaceAll("\\s*;\\s*", ";"); // value;property
        cleaned = cleaned.replaceAll(";$", ""); // Remove trailing semicolon if any
        // log.trace("After normalizing separator whitespace: '{}'", cleaned);


        // 6. Final trim (handles potential spaces after last semicolon removal)
        cleaned = cleaned.trim();
        // log.trace("Final cleaned style: '{}'", cleaned);
        return cleaned;
    }


    // --- Helper to check if a CSS property affects the font ---
    private boolean isFontProperty(String property) {
         return property.startsWith("font-") || property.equals("color") || property.equals("text-decoration");
    }

    // --- Helper to apply a single CSS property ---
    private boolean applyCssProperty(String property, String value, XSSFCellStyle style, XSSFFont font) {
        // (Implementation remains the same - calls specific apply/parse helpers)
        boolean applied = false;
        switch (property) {
            case "text-align": applied = applyTextAlign(style, value); break;
            case "vertical-align": applied = applyVerticalAlign(style, value); break;
            case "background-color": applied = applyBackgroundColor(style, value); break;
            case "color": applied = applyFontColor(font, value); break;
            case "font-weight": applied = applyFontWeight(font, value); break;
            case "font-style": applied = applyFontStyle(font, value); break;
            case "font-size": applied = parseFontSize(value, font); break;
            case "font-family": applied = parseFontFamily(value, font); break;
            case "text-decoration": applied = parseTextDecoration(value, font); break;
            case "white-space": if ("nowrap".equals(value)) style.setWrapText(false); else style.setWrapText(true); applied = true; break;
            case "border": applied = parseGeneralBorder(value, style); break;
            case "border-top": applied = parseSpecificBorder(value, style, BorderSide.TOP); break;
            case "border-bottom": applied = parseSpecificBorder(value, style, BorderSide.BOTTOM); break;
            case "border-left": applied = parseSpecificBorder(value, style, BorderSide.LEFT); break;
            case "border-right": applied = parseSpecificBorder(value, style, BorderSide.RIGHT); break;
             default: break;
        }
        return applied;
    }


    // --- All other helper methods (updateMaxChars, applyColumnWidths, setCellValue, ---
    // --- handleMergedRegions, applyTextAlign, applyVerticalAlign, applyBackgroundColor, ---
    // --- applyFontColor, applyFontWeight, applyFontStyle, parseFontSize, parseFontFamily, ---
    // --- parseTextDecoration, BorderSettings class, parseGeneralBorder, parseSpecificBorder, ---
    // --- parseBorderSettings, mapCssBorderStyle, parseColor, mapColorNameToRgb, constrain, ---
    // --- generateFontKey) remain IDENTICAL to the previous HTML->XLSX version. ---
    // --- Ensure you have copied them correctly from the previous correct response. ---

    // ... (Paste ALL the remaining helper methods from the previous correct response here) ...
    // --- Helper: Update max characters seen for a column ---
    private void updateMaxChars(Map<Integer, Integer> maxCharsMap, int colIndex, String text) {
        int length = (text != null) ? text.length() : 0;
        maxCharsMap.put(colIndex, Math.max(length, maxCharsMap.getOrDefault(colIndex, 0)));
    }

    // --- Helper: Apply estimated column widths ---
    private void applyColumnWidths(XSSFSheet sheet, Map<Integer, Integer> maxCharsMap) {
         final int charWidthFactor = 256; final int padding = 2;
         final double defaultCharWidthApproximation = 1.0; final int minWidthChars = 8;
         final int maxWidthChars = 100; final int excelMaxWidthUnits = 255 * charWidthFactor;
        log.debug("Applying estimated column widths for sheet '{}'", sheet.getSheetName());
        for (Map.Entry<Integer, Integer> entry : maxCharsMap.entrySet()) {
             int colIndex = entry.getKey(); int maxChars = entry.getValue();
             int clampedMaxChars = Math.min(maxChars, maxWidthChars);
             int width = (int) ((clampedMaxChars + padding) * defaultCharWidthApproximation * charWidthFactor);
             width = Math.max(width, minWidthChars * charWidthFactor);
             width = Math.min(width, excelMaxWidthUnits);
             try { sheet.setColumnWidth(colIndex, width); }
             catch (Exception e) { log.warn("Failed to set width for column {} on sheet '{}'. Error: {}", colIndex, sheet.getSheetName(), e.getMessage()); }
        }
    }


    // --- Helper: Set cell value with basic type detection ---
    private void setCellValue(XSSFCell cell, String text) {
        if (text == null) { cell.setBlank(); return; }
        String trimmedText = text.trim();
        if ("true".equalsIgnoreCase(trimmedText)) { cell.setCellValue(true); return; }
        if ("false".equalsIgnoreCase(trimmedText)) { cell.setCellValue(false); return; }
        if (NumberUtils.isCreatable(trimmedText)) {
            try { cell.setCellValue(Double.parseDouble(trimmedText)); return;
            } catch (NumberFormatException e) { /* Fallback */ }
        }
        cell.setCellValue(trimmedText);
    }

    // --- Helper: Handle Merged Regions ---
    private void handleMergedRegions(XSSFSheet sheet, boolean[][] occupied, int rIdx, int cIdx, int rowspan, int colspan) {
        if (rowspan > 1 || colspan > 1) {
            if (rIdx >= MAX_SUPPORTED_ROWS || cIdx >= MAX_SUPPORTED_COLS) return;
            int lastRow = Math.min(rIdx + rowspan - 1, MAX_SUPPORTED_ROWS - 1);
            int lastCol = Math.min(cIdx + colspan - 1, MAX_SUPPORTED_COLS - 1);
            if (lastRow < rIdx || lastCol < cIdx) return;
            try {
                CellRangeAddress mergedRegion = new CellRangeAddress(rIdx, lastRow, cIdx, lastCol);
                sheet.addMergedRegion(mergedRegion);
                log.trace("Added merged region: {}", mergedRegion.formatAsString());
                for (int r = rIdx; r <= lastRow; r++) {
                     if (r >= occupied.length) continue;
                    for (int c = cIdx; c <= lastCol; c++) {
                         if (c >= occupied[r].length) continue;
                         if (r > rIdx || c > cIdx) occupied[r][c] = true;
                    }
                }
            } catch (IllegalArgumentException e) { log.warn("Could not add merged region at row {}, col {} ({}x{}). Overlap or invalid range? {}", rIdx, cIdx, rowspan, colspan, e.getMessage());
            } catch (Exception e) { log.error("Error handling merged region at row {}, col {}", rIdx, cIdx, e); }
        }
    }


    // --- Style Application Helpers ---
    private boolean applyTextAlign(XSSFCellStyle style, String value) {
        HorizontalAlignment current = style.getAlignment(); HorizontalAlignment next = current;
        if ("center".equals(value)) next = HorizontalAlignment.CENTER;
        else if ("right".equals(value)) next = HorizontalAlignment.RIGHT;
        else if ("left".equals(value)) next = HorizontalAlignment.LEFT;
        else if ("justify".equals(value)) next = HorizontalAlignment.JUSTIFY;
        if (next != current) { style.setAlignment(next); return true; } return false;
    }

    private boolean applyVerticalAlign(XSSFCellStyle style, String value) {
        VerticalAlignment current = style.getVerticalAlignment(); VerticalAlignment next = current;
        if ("middle".equals(value)) next = VerticalAlignment.CENTER;
        else if ("top".equals(value)) next = VerticalAlignment.TOP;
        else if ("bottom".equals(value)) next = VerticalAlignment.BOTTOM;
        if (next != current) { style.setVerticalAlignment(next); return true; } return false;
    }

    private boolean applyBackgroundColor(XSSFCellStyle style, String value) {
        XSSFColor bgColor = parseColor(value);
        if (bgColor != null) { style.setFillForegroundColor(bgColor); style.setFillPattern(FillPatternType.SOLID_FOREGROUND); return true; } return false;
    }

    private boolean applyFontColor(XSSFFont font, String value) {
        XSSFColor fontColor = parseColor(value); XSSFColor currentColor = font.getXSSFColor();
        // Compare ARGB values for equality check, handle nulls
        boolean changed = (fontColor != null && !Objects.equal(getColorArgbHex(fontColor), getColorArgbHex(currentColor))) || (fontColor == null && currentColor != null);
        if (changed) { font.setColor(fontColor); return true; } return false;
    }
    // Helper to safely get ARGB Hex, returning null if color is null or complex
    private String getColorArgbHex(XSSFColor color) {
        if (color != null && color.isRGB() && color.hasTint() == 0.0) {
             try { return color.getARGBHex(); } catch (Exception e) { /* ignore */ }
        } return null;
    }


    private boolean applyFontWeight(XSSFFont font, String value) {
        boolean original = font.getBold(); boolean next = ("bold".equals(value) || "700".equals(value) || "800".equals(value) || "900".equals(value));
        if (next != original) { font.setBold(next); return true; } return false;
    }

     private boolean applyFontStyle(XSSFFont font, String value) {
        boolean original = font.getItalic(); boolean next = ("italic".equals(value) || "oblique".equals(value));
        if (next != original) { font.setItalic(next); return true; } return false;
     }

    // --- Font Size Parsing Helper ---
    private boolean parseFontSize(String value, XSSFFont font) {
        short originalSize = font.getFontHeightInPoints(); short points = -1;
        try {
            if (value.endsWith("pt")) points = Short.parseShort(value.substring(0, value.length() - 2).trim());
            else if (value.endsWith("px")) points = (short) Math.max(1, Math.round(Integer.parseInt(value.substring(0, value.length() - 2).trim()) * 0.75));
            else if (NumberUtils.isDigits(value)) points = Short.parseShort(value);
            else { switch(value) { case "xx-small": points = 6; break; case "x-small": points = 7; break; case "small": points = 8; break; case "medium": points = 10; break; case "large": points = 12; break; case "x-large": points = 14; break; case "xx-large": points = 18; break; } }
            if (points > 0 && points != originalSize) { font.setFontHeightInPoints(points); return true; }
        } catch (Exception e) { log.warn("Could not parse font-size: '{}'. Error: {}", value, e.getMessage()); } return false;
    }

    // --- Font Family Parsing Helper ---
    private boolean parseFontFamily(String value, XSSFFont font) {
        String originalName = font.getFontName(); String finalName = originalName;
        try {
            String[] families = value.split(","); if (families.length > 0) { String firstFamily = StringUtils.strip(families[0].trim(), "'\"");
            if (!"serif".equalsIgnoreCase(firstFamily) && !"sans-serif".equalsIgnoreCase(firstFamily) && !"monospace".equalsIgnoreCase(firstFamily) && !"cursive".equalsIgnoreCase(firstFamily) && !"fantasy".equalsIgnoreCase(firstFamily) && StringUtils.isNotBlank(firstFamily)) { finalName = firstFamily; }}
        } catch (Exception e) { log.warn("Could not parse font-family: '{}'. Error: {}", value, e.getMessage()); return false; }
        if (!StringUtils.equals(finalName, originalName)) { font.setFontName(finalName); return true; } return false;
    }

    // --- Text Decoration Parsing Helper ---
     private boolean parseTextDecoration(String value, XSSFFont font) {
         boolean changed = false; byte currentUnderline = font.getUnderline(); boolean currentStrike = font.getStrikeout();
         byte nextUnderline = Font.U_NONE; boolean nextStrike = false;
         if (value.contains("underline")) nextUnderline = Font.U_SINGLE;
         if (value.contains("line-through")) nextStrike = true;
         if (nextUnderline != currentUnderline) { font.setUnderline(nextUnderline); changed = true; }
         if (nextStrike != currentStrike) { font.setStrikeout(nextStrike); changed = true; } return changed;
     }

    // --- Border Parsing Helpers ---
    private static class BorderSettings { BorderStyle style = BorderStyle.NONE; XSSFColor color = null; }
    private boolean parseGeneralBorder(String value, XSSFCellStyle style) {
        BorderSettings settings = parseBorderSettings(value);
        // Only apply if settings were successfully parsed (even if it's 'none')
        if(settings != null){
            style.setBorderTop(settings.style); style.setTopBorderColor(settings.color);
            style.setBorderBottom(settings.style); style.setBottomBorderColor(settings.color);
            style.setBorderLeft(settings.style); style.setLeftBorderColor(settings.color);
            style.setBorderRight(settings.style); style.setRightBorderColor(settings.color);
            return true;
        }
        return false;
    }
    private boolean parseSpecificBorder(String value, XSSFCellStyle style, BorderSide side) {
         BorderSettings settings = parseBorderSettings(value);
         if (settings != null) {
             BorderStyle styleToSet = settings.style; XSSFColor colorToSet = settings.color;
             switch(side) {
                 case TOP: style.setBorderTop(styleToSet); style.setTopBorderColor(colorToSet); break;
                 case BOTTOM: style.setBorderBottom(styleToSet); style.setBottomBorderColor(colorToSet); break;
                 case LEFT: style.setBorderLeft(styleToSet); style.setLeftBorderColor(colorToSet); break;
                 case RIGHT: style.setBorderRight(styleToSet); style.setRightBorderColor(colorToSet); break;
             }
             return true;
         }
         return false;
    }
    private BorderSettings parseBorderSettings(String value) {
        if (StringUtils.isBlank(value)) return null; // Return null if value is blank
        String V = value.trim().toLowerCase();
        if ("none".equals(V) || "hidden".equals(V)) return new BorderSettings(); // Explicit none/hidden

        BorderSettings settings = new BorderSettings();
        settings.style = BorderStyle.NONE; // Start with none
        String[] parts = V.split("\\s+");

        for (String part : parts) {
            if (StringUtils.isBlank(part)) continue;
            if (settings.color == null) { XSSFColor parsedColor = parseColor(part); if (parsedColor != null) { settings.color = parsedColor; continue; }}
            BorderStyle parsedStyle = mapCssBorderStyle(part); if (parsedStyle != BorderStyle.NONE) { settings.style = parsedStyle; continue; }
            // Could add width parsing here ("1px", "thin", "medium") -> map to style thickness?
        }
        // If only color specified, default style to THIN
        if (settings.style == BorderStyle.NONE && settings.color != null) settings.style = BorderStyle.THIN;
        // Default color to black if style was set but no color found
        if (settings.style != BorderStyle.NONE && settings.color == null) settings.color = new XSSFColor(IndexedColors.BLACK.getIndexed(), new DefaultIndexedColorMap());

        return settings; // Return parsed settings (might still be NONE if unparseable)
    }
    private BorderStyle mapCssBorderStyle(String cssStyle) {
         switch (cssStyle) { case "solid": return BorderStyle.THIN; case "dashed": return BorderStyle.DASHED; case "dotted": return BorderStyle.DOTTED; case "double": return BorderStyle.DOUBLE; case "groove": return BorderStyle.GROOVE; case "ridge": return BorderStyle.RIDGE; case "inset": return BorderStyle.INSET; case "outset": return BorderStyle.OUTSET; case "thin": return BorderStyle.THIN; case "medium": return BorderStyle.MEDIUM; case "thick": return BorderStyle.THICK; case "hidden": case "none": default: return BorderStyle.NONE; }
    }

    // --- Color Parsing Helper ---
    private XSSFColor parseColor(String colorStr) {
         if (StringUtils.isBlank(colorStr)) return null; colorStr = colorStr.toLowerCase().trim(); byte[] rgb = null; IndexedColorMap colorMap = new DefaultIndexedColorMap();
        try { if (colorStr.startsWith("#")) { String hex = colorStr.substring(1); if (hex.length() == 3) hex = "" + hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2); if (hex.length() == 6) { rgb = new byte[]{ (byte)Integer.parseInt(hex.substring(0, 2), 16), (byte)Integer.parseInt(hex.substring(2, 4), 16), (byte)Integer.parseInt(hex.substring(4, 6), 16) }; }}
            else if (colorStr.startsWith("rgb(")) { String[] parts = colorStr.substring(4, colorStr.length() - 1).split(","); if (parts.length == 3) { rgb = new byte[]{ (byte) constrain(Integer.parseInt(parts[0].trim())), (byte) constrain(Integer.parseInt(parts[1].trim())), (byte) constrain(Integer.parseInt(parts[2].trim())) }; }}
            else if ("transparent".equals(colorStr)) { return null; } // Treat transparent as null/no color
            else { rgb = mapColorNameToRgb(colorStr); }
        } catch (Exception e) { log.warn("Could not parse color string: '{}'. Error: {}", colorStr, e.getMessage()); return null; }
        if (rgb != null) { try { return new XSSFColor(rgb, colorMap); } catch (Exception e) { log.warn("Failed to create XSSFColor from RGB for '{}'. Error: {}", colorStr, e.getMessage()); return null; }} return null;
    }
    private byte[] mapColorNameToRgb(String name) {
        switch (name) { case "black": return new byte[]{0, 0, 0}; case "white": return new byte[]{(byte)255, (byte)255, (byte)255}; case "red": return new byte[]{(byte)255, 0, 0}; case "lime": return new byte[]{0, (byte)255, 0}; case "green": return new byte[]{0, (byte)128, 0}; case "blue": return new byte[]{0, 0, (byte)255}; case "yellow": return new byte[]{(byte)255, (byte)255, 0}; case "cyan": case "aqua": return new byte[]{0, (byte)255, (byte)255}; case "magenta": case "fuchsia": return new byte[]{(byte)255, 0, (byte)255}; case "silver": return new byte[]{(byte)192, (byte)192, (byte)192}; case "gray": case "grey": return new byte[]{(byte)128, (byte)128, (byte)128}; case "maroon": return new byte[]{(byte)128, 0, 0}; case "olive": return new byte[]{(byte)128, (byte)128, 0}; case "purple": return new byte[]{(byte)128, 0, (byte)128}; case "teal": return new byte[]{0, (byte)128, (byte)128}; case "navy": return new byte[]{0, 0, (byte)128}; default: return null; }
    }
    private int constrain(int value) { return Math.max(0, Math.min(255, value)); }

    // --- Helper to generate a unique key for font caching ---
    private String generateFontKey(XSSFFont font) {
        String colorHex = getColorArgbHex(font.getXSSFColor()); // Use helper to get comparable color string
        return String.format("%s|%d|%s|%b|%b|%b|%d|%d", font.getFontName(), font.getFontHeightInPoints(), colorHex, font.getBold(), font.getItalic(), font.getStrikeout(), font.getUnderline(), font.getTypeOffset());
    }

    // Needed by applyFontColor for comparison, defined earlier
    // Helper to safely get ARGB Hex, returning null if color is null or complex
    private String getColorArgbHex(XSSFColor color) {
        if (color != null && color.isRGB() && color.hasTint() == 0.0) {
             try { return color.getARGBHex(); } catch (Exception e) { /* ignore */ }
        } return "auto"; // Return "auto" or null for non-comparable colors
    }
    // Required import: import java.util.Objects; (or use Guava if available)
    private static class Objects { public static boolean equal(Object a, Object b) { return (a == b) || (a != null && a.equals(b)); } }


}
```

**关键变化:**

1.  **`cleanAndDecodeStyleAttribute` 更新:** 这个辅助方法现在包含了更明确的步骤来处理前端可能使用的反斜杠转义：
    * 移除包裹的引号 (`"` 或 `&quot;`)。
    * 执行标准的 HTML 实体解码 (`Parser.unescapeEntities`)。
    * **替换转义序列:** 将 `\:`, `\;`, `\"`, 和 `\ ` (反斜杠加空格) 分别替换为 `:`, `;`, `"`, 和空字符串（假设 `\ ` 只是为了分隔）。
    * **规范化空白:** 使用 `replaceAll` 清理分隔符周围的空白，确保格式为 `property:value;`。
    * 移除末尾可能存在的多余分隔符。
2.  **其余部分:** 代码的其他部分（主转换方法、表格处理、其他辅助方法）与上一个 HTML->XLSX 版本基本一致，因为它们现在接收的是经过强化的 `cleanAndDecodeStyleAttribute` 方法处理过的、更标准的 CSS 字符串。

这个版本应该能够更可靠地解析来自前端的、包含特定反斜杠转义的 `style` 属性，从而提高样式转换的成功率。