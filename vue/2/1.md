/**
* htmlTableToExcel.js - HTML表格导出为Excel工具
* 优化版本：修复合并单元格数据丢失和样式保留问题
  */

// 使用xlsx-js-style库以支持样式
import * as XLSX from 'xlsx-js-style';

/**
* 将HTML表格转换为Excel文件并下载
* @param {string} tableHtml - 表格的HTML字符串
* @param {string} fileName - 下载的文件名（不含扩展名）
* @param {object} options - 配置选项
* @returns {Promise<object>} 导出结果
  */
  export const htmlTableToExcel = (tableHtml, fileName, options = {}) => {
  return new Promise((resolve, reject) => {
  try {
  // 默认配置
  const defaultOptions = {
  sheetName: '表格数据',
  includeStyles: true,
  autoWidth: true,
  preserveMerges: true
  };

  // 合并配置
  const config = { ...defaultOptions, ...options };

  // 解析HTML
  const parser = new DOMParser();
  const doc = parser.parseFromString(tableHtml, 'text/html');
  const table = doc.querySelector('table');

  if (!table) {
  reject(new Error('无效的表格HTML'));
  return;
  }

  // 创建工作簿
  const wb = XLSX.utils.book_new();

  // 第一步：创建数据结构化视图
  const tableView = createTableView(table);

  // 第二步：构建Excel数据矩阵并处理样式
  const { dataMatrix, styles, merges } = buildExcelMatrix(tableView, config);

  // 第三步：创建工作表
  const ws = XLSX.utils.aoa_to_sheet(dataMatrix);

  // 第四步：应用合并单元格
  if (config.preserveMerges && merges.length > 0) {
  ws['!merges'] = merges;
  }

  // 第五步：设置列宽和行高
  if (config.autoWidth) {
  ws['!cols'] = calculateColumnWidths(dataMatrix);
  }

  // 设置行高
  ws['!rows'] = calculateRowHeights(table, dataMatrix.length);

  // 第六步：应用样式
  if (config.includeStyles) {
  applyStylesToWorksheet(ws, styles);
  }

  // 第七步：添加工作表到工作簿并导出
  XLSX.utils.book_append_sheet(wb, ws, config.sheetName);
  XLSX.writeFile(wb, `${fileName}.xlsx`);

  resolve({
  success: true,
  fileName: `${fileName}.xlsx`,
  rows: dataMatrix.length,
  cols: dataMatrix[0] ? dataMatrix[0].length : 0
  });
  } catch (error) {
  console.error('导出表格时出错:', error);
  reject(error);
  }
  });
  };

/**
* 创建表格的结构化视图
* @param {HTMLTableElement} table - 表格元素
* @returns {object} 表格视图对象
  */
  function createTableView(table) {
  const rows = table.rows;
  const rowCount = rows.length;

// 计算表格的总列数
let maxCols = 0;
for (let i = 0; i < rowCount; i++) {
let colSpanSum = 0;
const cells = rows[i].cells;
for (let j = 0; j < cells.length; j++) {
colSpanSum += parseInt(cells[j].getAttribute('colspan') || 1);
}
maxCols = Math.max(maxCols, colSpanSum);
}

// 创建二维数组，用于存储单元格信息
const cellGrid = Array(rowCount).fill().map(() => Array(maxCols).fill(null));

// 用于跟踪已经被合并单元格占用的位置
const occupiedPositions = Array(rowCount).fill().map(() => Array(maxCols).fill(false));

// 填充单元格信息
for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
const row = rows[rowIndex];
const cells = row.cells;

    let colIndex = 0;
    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
      // 找到下一个未被占用的位置
      while (colIndex < maxCols && occupiedPositions[rowIndex][colIndex]) {
        colIndex++;
      }
      
      if (colIndex >= maxCols) break;
      
      const cell = cells[cellIndex];
      const rowspan = parseInt(cell.getAttribute('rowspan') || 1);
      const colspan = parseInt(cell.getAttribute('colspan') || 1);
      
      // 创建单元格信息对象
      const cellInfo = {
        element: cell,
        content: cell.textContent.trim(),
        rowspan,
        colspan,
        rowIndex,
        colIndex,
        style: window.getComputedStyle(cell)
      };
      
      // 存储单元格信息
      cellGrid[rowIndex][colIndex] = cellInfo;
      
      // 标记被合并单元格占用的位置
      for (let r = 0; r < rowspan; r++) {
        for (let c = 0; c < colspan; c++) {
          if (rowIndex + r < rowCount && colIndex + c < maxCols) {
            occupiedPositions[rowIndex + r][colIndex + c] = true;
          }
        }
      }
      
      // 移动到下一个列位置
      colIndex += colspan;
    }
}

return {
rowCount,
colCount: maxCols,
cellGrid,
tableElement: table
};
}

/**
* 构建Excel数据矩阵
* @param {object} tableView - 表格视图对象
* @param {object} config - 配置选项
* @returns {object} Excel数据和样式
  */
  function buildExcelMatrix(tableView, config) {
  const { rowCount, colCount, cellGrid } = tableView;

// 创建数据矩阵
const dataMatrix = Array(rowCount).fill().map(() => Array(colCount).fill(''));

// 样式矩阵
const styles = {};

// 合并单元格列表
const merges = [];

// 填充数据矩阵和样式
for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
// 确保样式对象存在
styles[rowIndex] = {};

    for (let colIndex = 0; colIndex < colCount; colIndex++) {
      const cellInfo = cellGrid[rowIndex][colIndex];
      
      if (cellInfo) {
        // 设置单元格内容
        dataMatrix[rowIndex][colIndex] = cellInfo.content;
        
        // 处理合并单元格
        if (cellInfo.rowspan > 1 || cellInfo.colspan > 1) {
          merges.push({
            s: { r: rowIndex, c: colIndex },
            e: { r: rowIndex + cellInfo.rowspan - 1, c: colIndex + cellInfo.colspan - 1 }
          });
        }
        
        // 处理样式
        if (config.includeStyles) {
          styles[rowIndex][colIndex] = extractCellStyle(cellInfo);
        }
      }
    }
}

return { dataMatrix, styles, merges };
}

/**
* 提取单元格样式
* @param {object} cellInfo - 单元格信息
* @returns {object} Excel样式对象
  */
  function extractCellStyle(cellInfo) {
  const { style } = cellInfo;
  const excelStyle = {};

// 背景色
const backgroundColor = style.backgroundColor;
if (backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent') {
excelStyle.fill = {
fgColor: { rgb: rgbToHex(backgroundColor) },
patternType: 'solid'
};
}

// 字体
excelStyle.font = {
name: style.fontFamily.split(',')[0].replace(/['"]/g, '').trim() || 'Arial',
sz: parseInt(style.fontSize) || 12,
color: { rgb: rgbToHex(style.color) },
bold: style.fontWeight === 'bold' || parseInt(style.fontWeight) >= 700,
italic: style.fontStyle === 'italic',
underline: style.textDecoration.includes('underline'),
strike: style.textDecoration.includes('line-through')
};

// 对齐方式
excelStyle.alignment = {
horizontal: convertHorizontalAlign(style.textAlign),
vertical: convertVerticalAlign(style.verticalAlign),
wrapText: true
};

// 边框
const borderStyle = {
top: getBorderStyle(style.borderTop),
right: getBorderStyle(style.borderRight),
bottom: getBorderStyle(style.borderBottom),
left: getBorderStyle(style.borderLeft)
};

if (borderStyle.top || borderStyle.right || borderStyle.bottom || borderStyle.left) {
excelStyle.border = borderStyle;
}

return excelStyle;
}

/**
* 将RGB颜色转换为十六进制
* @param {string} rgb - RGB颜色字符串
* @returns {string} 十六进制颜色
  */
  function rgbToHex(rgb) {
  if (!rgb) return 'FF000000'; // 默认黑色

// 解析RGB值
const rgbMatch = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/i);
if (!rgbMatch) return 'FF000000';

const r = parseInt(rgbMatch[1]);
const g = parseInt(rgbMatch[2]);
const b = parseInt(rgbMatch[3]);
const a = rgbMatch[4] ? Math.round(parseFloat(rgbMatch[4]) * 255) : 255;

// 转换为十六进制
return ((a << 24) | (r << 16) | (g << 8) | b).toString(16).padStart(8, '0').toUpperCase();
}

/**
* 获取边框样式
* @param {string} borderStyle - CSS边框样式
* @returns {object|null} 边框样式对象
  */
  function getBorderStyle(borderStyle) {
  if (!borderStyle || borderStyle === 'none' || borderStyle === '0px none') {
  return null;
  }

// 匹配边框宽度、样式和颜色
const borderMatch = borderStyle.match(/(\d+(?:\.\d+)?px)\s+(\w+)\s+([^;]+)/i);
if (!borderMatch) return null;

const width = parseFloat(borderMatch[1]);
const style = borderMatch[2];
const color = borderMatch[3];

// 确定Excel边框样式
let excelBorderStyle = 'thin';
if (width > 3) {
excelBorderStyle = 'thick';
} else if (width > 1) {
excelBorderStyle = 'medium';
}

// 特殊边框样式
if (style === 'dashed') excelBorderStyle = 'dashed';
if (style === 'dotted') excelBorderStyle = 'dotted';
if (style === 'double') excelBorderStyle = 'double';

return {
style: excelBorderStyle,
color: { rgb: rgbToHex(color) }
};
}

/**
* 转换水平对齐方式
* @param {string} align - CSS对齐方式
* @returns {string} Excel对齐方式
  */
  function convertHorizontalAlign(align) {
  const alignMap = {
  left: 'left',
  center: 'center',
  right: 'right',
  justify: 'justify'
  };

return alignMap[align] || 'left';
}

/**
* 转换垂直对齐方式
* @param {string} align - CSS对齐方式
* @returns {string} Excel对齐方式
  */
  function convertVerticalAlign(align) {
  const alignMap = {
  top: 'top',
  middle: 'center',
  bottom: 'bottom'
  };

return alignMap[align] || 'center';
}

/**
* 计算列宽
* @param {Array} dataMatrix - 数据矩阵
* @returns {Array} 列宽数组
  */
  function calculateColumnWidths(dataMatrix) {
  if (!dataMatrix || dataMatrix.length === 0) return [];

const colCount = dataMatrix[0].length;
const colWidths = Array(colCount).fill().map(() => ({ wch: 10 })); // 默认列宽10

// 遍历所有单元格，找出每列的最大内容宽度
for (let row = 0; row < dataMatrix.length; row++) {
for (let col = 0; col < dataMatrix[row].length; col++) {
const content = String(dataMatrix[row][col] || '');
if (content) {
// 计算内容宽度（考虑中文字符宽度是英文字符的2倍）
let width = 0;
for (let i = 0; i < content.length; i++) {
width += /[\u4e00-\u9fa5]/.test(content[i]) ? 2 : 1;
}

        // 更新列宽（加上一些边距）
        const contentWidth = Math.min(Math.max(8, width + 4), 50); // 限制列宽在8-50之间
        colWidths[col].wch = Math.max(colWidths[col].wch, contentWidth);
      }
    }
}

return colWidths;
}

/**
* 计算行高
* @param {HTMLTableElement} table - 表格元素
* @param {number} rowCount - 行数
* @returns {Array} 行高数组
  */
  function calculateRowHeights(table, rowCount) {
  const rows = table.rows;
  const rowHeights = [];

for (let i = 0; i < rowCount; i++) {
if (i < rows.length) {
// 使用实际行高
const height = rows[i].offsetHeight;
// 将像素转换为点（1px ≈ 0.75pt）
rowHeights.push({ hpt: Math.max(12, Math.round(height * 0.75)) });
} else {
// 默认行高
rowHeights.push({ hpt: 15 });
}
}

return rowHeights;
}

/**
* 应用样式到工作表
* @param {object} ws - 工作表对象
* @param {object} styles - 样式映射
  */
  function applyStylesToWorksheet(ws, styles) {
  for (const row in styles) {
  for (const col in styles[row]) {
  const cellRef = XLSX.utils.encode_cell({ r: parseInt(row), c: parseInt(col) });

  // 确保单元格存在
  if (!ws[cellRef]) {
  ws[cellRef] = { v: '' };
  }

  // 应用样式
  ws[cellRef].s = styles[row][col];
  }
  }
  }

/**
* 为页面上的表格添加导出按钮
* @param {string} tableSelector - 表格选择器
* @param {string} buttonText - 按钮文本
* @param {string} buttonClass - 按钮类名
* @param {string} fileNamePrefix - 文件名前缀
  */
  export const addExportButtonsToTables = (tableSelector, buttonText = '导出Excel', buttonClass = 'export-excel-btn', fileNamePrefix = 'table') => {
  const tables = document.querySelectorAll(tableSelector);

tables.forEach((table, index) => {
// 创建按钮
const button = document.createElement('button');
button.textContent = buttonText;
button.className = buttonClass;

    // 点击事件
    button.addEventListener('click', () => {
      htmlTableToExcel(table.outerHTML, `${fileNamePrefix}-${index + 1}`)
        .then(result => console.log('导出成功:', result))
        .catch(error => console.error('导出失败:', error));
    });
    
    // 插入按钮
    table.parentNode.insertBefore(button, table.nextSibling);
});
};

export default {
htmlTableToExcel,
addExportButtonsToTables
};