我将为您完整输出带有日志打印功能的HTML表格导出工具类，以便验证样式是否成功获取。

```javascript
/**
 * htmlTableToExcel.js - HTML表格导出为Excel工具
 * 增强版：添加样式获取日志和验证
 */

// 导入Excel库（确保使用xlsx-js-style而不是xlsx）
import * as XLSX from 'xlsx-js-style';

/**
 * 将HTML表格转换为Excel文件并下载
 * @param {string} tableHtml - 表格的HTML字符串
 * @param {string} fileName - 下载的文件名（不含扩展名）
 * @param {object} options - 配置选项
 * @returns {Promise<void>}
 */
export const htmlTableToExcel = (tableHtml, fileName, options = {}) => {
  return new Promise((resolve, reject) => {
    try {
      console.log('开始处理表格导出...', { fileName });
      
      // 默认配置
      const defaultOptions = {
        sheetName: '表格数据',
        includeStyles: true,
        autoWidth: true,
        maxCellWidth: 50,  // 最大列宽
        defaultFontSize: 12,
        defaultFontName: 'Arial',
        preserveColors: true,
        preserveBorders: true,
        preserveAlignment: true,
        defaultRowHeight: 15,
        debug: true  // 启用调试日志
      };
      
      // 合并配置
      const config = { ...defaultOptions, ...options };
      
      // 使用浏览器DOM API解析HTML
      const parser = new DOMParser();
      const doc = parser.parseFromString(tableHtml, 'text/html');
      const table = doc.querySelector('table');
      
      if (!table) {
        console.error('无效的表格HTML');
        reject(new Error('无效的表格HTML'));
        return;
      }
      
      console.log('成功解析表格HTML', { 
        rowCount: table.rows.length, 
        firstRowCellCount: table.rows[0]?.cells.length
      });
      
      // 创建工作簿和工作表
      const wb = XLSX.utils.book_new();
      
      // 获取表格行
      const rows = table.rows;
      if (rows.length === 0) {
        console.error('表格没有行');
        reject(new Error('表格没有行'));
        return;
      }
      
      // 数据和样式映射
      const data = [];
      const merges = [];
      const styles = {};
      const colWidths = [];
      const rowHeights = [];
      
      // 日志：记录单元格样式获取情况
      const styleLog = {
        totalCells: 0,
        styledCells: 0,
        bgColorCells: 0,
        fontCells: 0,
        alignmentCells: 0,
        borderCells: 0
      };
      
      console.log('开始处理表格数据和样式...');
      
      // 处理每一行
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const row = rows[rowIndex];
        const cells = row.cells;
        const rowData = [];
        
        // 初始化行样式
        styles[rowIndex] = {};
        
        // 获取行高
        const height = row.offsetHeight || 0;
        rowHeights.push({ hpt: Math.ceil(height * 0.75) || config.defaultRowHeight });
        
        // 处理每个单元格
        for (let colIndex = 0; colIndex < cells.length; colIndex++) {
          const cell = cells[colIndex];
          styleLog.totalCells++;
          
          // 获取单元格内容
          const cellContent = cell.textContent.trim();
          rowData.push(cellContent);
          
          // 获取rowspan和colspan
          const rowspan = parseInt(cell.getAttribute('rowspan')) || 1;
          const colspan = parseInt(cell.getAttribute('colspan')) || 1;
          
          // 处理合并单元格
          if (rowspan > 1 || colspan > 1) {
            const mergeRange = {
              s: { r: rowIndex, c: colIndex },
              e: { r: rowIndex + rowspan - 1, c: colIndex + colspan - 1 }
            };
            merges.push(mergeRange);
            
            if (config.debug) {
              console.log(`检测到合并单元格 [${rowIndex},${colIndex}]`, { 
                rowspan, 
                colspan, 
                content: cellContent.substring(0, 20) + (cellContent.length > 20 ? '...' : '')
              });
            }
          }
          
          // 处理单元格样式
          if (config.includeStyles) {
            const cellStyle = getEnhancedCellStyle(cell, config);
            styles[rowIndex][colIndex] = cellStyle;
            
            // 记录样式日志
            styleLog.styledCells++;
            if (cellStyle.fill) styleLog.bgColorCells++;
            if (cellStyle.font) styleLog.fontCells++;
            if (cellStyle.alignment) styleLog.alignmentCells++;
            if (cellStyle.border) styleLog.borderCells++;
            
            // 详细日志
            if (config.debug && (rowIndex < 2 || rowIndex >= rows.length - 2)) {
              console.log(`单元格 [${rowIndex},${colIndex}] 样式:`, JSON.stringify(cellStyle));
            }
          }
          
          // 计算列宽
          if (config.autoWidth) {
            const contentWidth = getContentWidth(cellContent);
            if (colIndex >= colWidths.length) {
              colWidths.push({ wch: Math.min(contentWidth, config.maxCellWidth) });
            } else {
              colWidths[colIndex].wch = Math.max(colWidths[colIndex].wch || 8, Math.min(contentWidth, config.maxCellWidth));
            }
          }
        }
        
        // 添加行数据
        data.push(rowData);
      }
      
      // 输出样式统计日志
      console.log('单元格样式统计:', {
        totalCells: styleLog.totalCells,
        styledCells: styleLog.styledCells,
        withBgColor: styleLog.bgColorCells,
        withFont: styleLog.fontCells,
        withAlignment: styleLog.alignmentCells,
        withBorder: styleLog.borderCells,
        styleRatio: (styleLog.styledCells / styleLog.totalCells * 100).toFixed(2) + '%'
      });
      
      // 创建工作表
      console.log('创建Excel工作表...');
      const ws = XLSX.utils.aoa_to_sheet(data);
      
      // 应用合并单元格
      console.log(`应用 ${merges.length} 个单元格合并...`);
      ws['!merges'] = merges;
      
      // 应用列宽
      console.log(`应用 ${colWidths.length} 个列宽设置...`);
      ws['!cols'] = colWidths;
      
      // 应用行高
      console.log(`应用 ${rowHeights.length} 个行高设置...`);
      ws['!rows'] = rowHeights;
      
      // 应用样式
      console.log('开始应用单元格样式...');
      const appliedStyles = applyEnhancedStyles(ws, styles);
      console.log(`成功应用 ${appliedStyles} 个单元格样式`);
      
      // 将工作表添加到工作簿
      XLSX.utils.book_append_sheet(wb, ws, config.sheetName);
      
      // 检查xlsx-js-style库是否正确安装和使用
      const hasStyleSupport = checkXlsxStyleSupport();
      if (!hasStyleSupport) {
        console.warn('警告: 可能未正确安装或使用xlsx-js-style库，样式可能不会正确显示。');
      }
      
      // 生成Excel文件并下载
      console.log('生成Excel文件并下载...');
      XLSX.writeFile(wb, `${fileName}.xlsx`);
      
      console.log('表格导出完成!');
      resolve({
        success: true,
        fileName: `${fileName}.xlsx`,
        rowCount: data.length,
        colCount: data[0]?.length || 0,
        styleStats: styleLog
      });
    } catch (error) {
      console.error('导出表格时出错:', error);
      reject(error);
    }
  });
};

/**
 * 检查是否正确使用了xlsx-js-style库
 * @returns {boolean} 是否支持样式
 */
function checkXlsxStyleSupport() {
  try {
    // 检查XLSX版本和特定的样式相关函数
    const hasVersionInfo = typeof XLSX.version === 'string';
    const hasStyleFunctions = 
      typeof XLSX.utils.book_append_sheet === 'function' && 
      typeof XLSX.writeFile === 'function';
    
    console.log('XLSX库信息:', {
      version: XLSX.version,
      hasStyleFunctions
    });
    
    // 尝试创建带样式的单元格
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet([["测试"]]);
    ws['A1'].s = { font: { bold: true } };
    
    return hasVersionInfo && hasStyleFunctions;
  } catch (e) {
    console.error('检查xlsx-js-style支持时出错:', e);
    return false;
  }
}

/**
 * 获取增强的单元格样式
 * @param {HTMLElement} cell - 单元格元素
 * @param {object} config - 配置选项
 * @returns {object} 样式对象
 */
function getEnhancedCellStyle(cell, config) {
  const computedStyle = window.getComputedStyle(cell);
  const style = {};
  
  // 处理背景色
  if (config.preserveColors) {
    const backgroundColor = computedStyle.backgroundColor;
    if (backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent') {
      style.fill = {
        fgColor: { rgb: formatColor(backgroundColor) },
        patternType: 'solid' // 这个属性非常重要
      };
    }
    
    // 处理文字颜色
    const color = computedStyle.color;
    if (color) {
      style.font = style.font || {};
      style.font.color = { rgb: formatColor(color) };
    }
  }
  
  // 处理字体样式
  style.font = style.font || {};
  style.font.name = computedStyle.fontFamily.split(',')[0].replace(/['"]/g, '').trim() || config.defaultFontName;
  style.font.sz = parseInt(computedStyle.fontSize) || config.defaultFontSize;
  style.font.bold = computedStyle.fontWeight === 'bold' || parseInt(computedStyle.fontWeight) >= 700;
  style.font.italic = computedStyle.fontStyle === 'italic';
  style.font.underline = computedStyle.textDecoration.includes('underline');
  style.font.strike = computedStyle.textDecoration.includes('line-through');
  
  // 处理对齐方式
  if (config.preserveAlignment) {
    style.alignment = {
      horizontal: getHorizontalAlign(computedStyle.textAlign),
      vertical: getVerticalAlign(computedStyle.verticalAlign),
      wrapText: true
    };
  }
  
  // 处理边框
  if (config.preserveBorders) {
    const borderTop = getBorderStyle(computedStyle.borderTop);
    const borderRight = getBorderStyle(computedStyle.borderRight);
    const borderBottom = getBorderStyle(computedStyle.borderBottom);
    const borderLeft = getBorderStyle(computedStyle.borderLeft);
    
    // 只有当至少有一个边框存在时才添加边框样式
    if (borderTop || borderRight || borderBottom || borderLeft) {
      style.border = {
        top: borderTop || { style: 'thin', color: { rgb: 'FF000000' } },
        right: borderRight || { style: 'thin', color: { rgb: 'FF000000' } },
        bottom: borderBottom || { style: 'thin', color: { rgb: 'FF000000' } },
        left: borderLeft || { style: 'thin', color: { rgb: 'FF000000' } }
      };
    }
  }
  
  return style;
}

/**
 * 格式化颜色为Excel所需的格式
 * @param {string} color - CSS颜色字符串
 * @returns {string} 格式化的颜色
 */
function formatColor(color) {
  // 解析RGB或RGBA颜色
  const rgba = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/i);
  if (!rgba) return 'FF000000'; // 默认黑色
  
  const r = parseInt(rgba[1]).toString(16).padStart(2, '0');
  const g = parseInt(rgba[2]).toString(16).padStart(2, '0');
  const b = parseInt(rgba[3]).toString(16).padStart(2, '0');
  const a = rgba[4] ? Math.round(parseFloat(rgba[4]) * 255).toString(16).padStart(2, '0') : 'FF';
  
  // 返回ARGB格式（Excel使用）
  return `${a}${r}${g}${b}`.toUpperCase();
}

/**
 * 获取边框样式
 * @param {string} borderStyle - CSS边框样式
 * @returns {object|null} 边框样式对象
 */
function getBorderStyle(borderStyle) {
  if (!borderStyle || borderStyle === 'none' || borderStyle === '0px none') {
    return null;
  }
  
  // 尝试匹配边框宽度、样式和颜色
  const borderMatch = borderStyle.match(/(\d+(?:\.\d+)?px)\s+(\w+)\s+([^;]+)/i);
  if (!borderMatch) return null;
  
  const width = parseFloat(borderMatch[1]);
  const style = borderMatch[2];
  const color = borderMatch[3];
  
  // 确定Excel边框样式
  let excelBorderStyle = 'thin';
  if (width > 3) {
    excelBorderStyle = 'thick';
  } else if (width > 1) {
    excelBorderStyle = 'medium';
  }
  
  // 特殊边框样式
  if (style === 'dashed') excelBorderStyle = 'dashed';
  if (style === 'dotted') excelBorderStyle = 'dotted';
  if (style === 'double') excelBorderStyle = 'double';
  
  return {
    style: excelBorderStyle,
    color: { rgb: formatColor(color) }
  };
}

/**
 * 获取水平对齐方式
 * @param {string} textAlign - CSS文本对齐方式
 * @returns {string} Excel水平对齐方式
 */
function getHorizontalAlign(textAlign) {
  switch (textAlign) {
    case 'left': return 'left';
    case 'center': return 'center';
    case 'right': return 'right';
    case 'justify': return 'justify';
    default: return 'left';
  }
}

/**
 * 获取垂直对齐方式
 * @param {string} verticalAlign - CSS垂直对齐方式
 * @returns {string} Excel垂直对齐方式
 */
function getVerticalAlign(verticalAlign) {
  switch (verticalAlign) {
    case 'top': return 'top';
    case 'middle': return 'center';
    case 'bottom': return 'bottom';
    default: return 'center';
  }
}

/**
 * 计算内容宽度
 * @param {string} content - 单元格内容
 * @returns {number} 列宽
 */
function getContentWidth(content) {
  // 简单估算：一个中文字符约等于2个英文字符宽
  let width = 0;
  for (let i = 0; i < content.length; i++) {
    if (/[\u4e00-\u9fa5]/.test(content.charAt(i))) {
      width += 2;
    } else {
      width += 1;
    }
  }
  
  // 加上边距空间
  return Math.max(8, width + 4);
}

/**
 * 应用增强样式到工作表
 * @param {object} ws - 工作表对象
 * @param {object} styles - 样式映射
 * @returns {number} 应用的样式数量
 */
function applyEnhancedStyles(ws, styles) {
  let appliedCount = 0;
  
  for (const row in styles) {
    for (const col in styles[row]) {
      const cellRef = XLSX.utils.encode_cell({ r: parseInt(row), c: parseInt(col) });
      
      // 确保单元格存在
      if (ws[cellRef]) {
        // 直接设置样式属性
        ws[cellRef].s = styles[row][col];
        appliedCount++;
      }
    }
  }
  
  return appliedCount;
}

/**
 * 为表格中的导出按钮添加事件处理
 * @param {string} tableSelector - 表格选择器
 * @param {string} buttonSelector - 按钮选择器
 * @param {string} fileName - 文件名（不含扩展名）
 */
export const setupTableExportButtons = (tableSelector, buttonSelector, fileName = 'table-export') => {
  // 获取所有表格
  const tables = document.querySelectorAll(tableSelector);
  console.log(`为 ${tables.length} 个表格设置导出按钮`);
  
  tables.forEach((table, index) => {
    // 在表格后添加导出按钮
    const exportButton = document.createElement('button');
    exportButton.className = buttonSelector.replace(/^\./, ''); // 移除选择器前的点
    exportButton.textContent = `导出表格 ${index + 1}`;
    exportButton.addEventListener('click', () => {
      const tableHtml = table.outerHTML;
      console.log(`准备导出表格 ${index + 1}`, { 
        rows: table.rows.length, 
        cols: table.rows[0]?.cells.length 
      });
      
      htmlTableToExcel(tableHtml, `${fileName}-${index + 1}`)
        .then(result => {
          console.log(`表格 ${index + 1} 导出成功`, result);
        })
        .catch(error => {
          console.error(`表格 ${index + 1} 导出失败:`, error);
        });
    });
    
    // 将按钮添加到表格后
    table.parentNode.insertBefore(exportButton, table.nextSibling);
  });
};

export default {
  htmlTableToExcel,
  setupTableExportButtons
};
```

这个强化版本的工具类添加了全面的日志打印功能，可以帮助您确认以下几点：

1. **样式是否成功获取**：
    - 记录每个单元格的样式获取情况
    - 统计不同类型样式（背景色、字体、对齐、边框）的获取数量
    - 计算样式获取率

2. **合并单元格是否正确处理**：
    - 打印每个检测到的合并单元格信息
    - 显示应用的合并单元格总数

3. **Excel库版本和支持情况**：
    - 检查是否正确使用了xlsx-js-style库
    - 验证库是否支持样式功能

4. **样式应用状态**：
    - 记录实际应用样式的单元格数量
    - 输出前几行和最后几行单元格的详细样式

使用方法不变，但现在会在控制台输出详细的日志信息，帮助您诊断样式不显示的问题。如果表格确实有样式但Excel中没有显示，您可以通过日志确认样式是否成功获取和应用。

要使这个工具类正确工作，您需要确保：

1. 已安装xlsx-js-style库（而不是xlsx）：`npm install xlsx-js-style --save`
2. 在项目中正确导入：`import * as XLSX from 'xlsx-js-style';`
3. 导出的Excel文件使用支持样式的Excel应用程序打开（如Microsoft Excel或WPS Office）

这个工具类现在包含了全面的日志，应该能帮助您确定样式问题的根本原因。